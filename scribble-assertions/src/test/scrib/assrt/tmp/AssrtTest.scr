//Raymond@HZHL3 ~/code/eclipse/scribble/github.com/rumineykova/scribble-java
//$ bin/scribblec-assrt.sh -ip scribble-assertions/src/test/scrib/ -d scribble-assertions/src/test/scrib/ scribble-assertions/src/test/scrib/assrt/tmp/AssrtTest.scr 


// http://sandbox.kidstrythisathome.com/erdos/


module assrt.tmp.AssrtTest;


type <dotnet> "System.UInt32" from "..." as int;
type <dotnet> "System.String" from "..." as str;


// FIXME: debug printing for assertion passes

// FIXME: distinguish branches where "not guaranteed safe" vs "impossible"


// - assertion validation
// - receive assertions -- why receive assertions?  should WF imply receive assertions always true?
// - explicit connections

//	.. rename connect to request
//	.. refactor a GConnectionAction (cf. LConnectionAction)

// .. need to update SubprotocolSig and "cycle" detection for protocoldecl/do annots? -- protocol inlining/unfolding with annots/assertions
// .. how about "syntactic" reachability check with protocoldecl/do annots?

// - recursion annotations
// - port forwarding annotations/assertions
// - arrays? -- cf. dependent types for array/list lengths -- https://www.reddit.com/r/fsharp/comments/28bbsr/faking_dependent_types_in_f/

// redo inlining/unfolding via model building? role/param/assert all in model states?


//*
global protocol Proto1(role B, role W, role S)
{
	1(Query:int) from B to W; @(Query>0);
	2(Instock:int) from W to S; @(Instock<Query);
	3a(Available:int) from S to B; @(Available=Instock);
	3b(Quote:int) from S to B;
	
	choice at B
	{
		ok() from B to S; @(Available>0); 
		ok() from B to W;
		do Proto2(B, W, S); @Quote;
	}
	or
	{
		quit() from B to S;
		quit() from B to W;
	}
}

global protocol Proto2(role B, role W, role S) @(x=0);
{
	5(Offer:int) from B to S;	
	choice at S
	{
		hag() from S to B; @(Offer>x);
		hag() from S to W; //@False;  // Uncomment is assert-prog error
		do Proto2(B, W, S); @Offer;
	}
	or
	{
		exit() from S to B; //@False;  // Uncomment is still assert-prog, but unsat
		cancel() from S to W; //@False;  // Uncomment is assert-prog error if above is commented; otherwise this is assert-prog
	}
	or
	{
		sell() from S to B;
		commit() from S to W;
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;
	choice at A
	{
		2() from A to B;
	}
	//or { 3() from A to B; @False; }  // Uncomment is unsat
	or
	{
		4() from A to B; @(x>3);  // Assertion-progress because of first case
	}
}
//*/

/*
global protocol Proto1(role B, role S)
{
	ok() from B to S;
	do Proto2(B, S); @Quote;  // FIXME: unknown vars check
}

global protocol Proto2(role B, role S) @(x=0);
{
	5() from B to S;	@False;//@(y>0);
}
//*/


/*
global protocol JavaSmtBug(role B, role S) @(x=0);
{
	5() from B to S;	@False;//@(y>0);
	do JavaSmtBug(B, S); @x;  // Cf. AssrtExistsFormula::toJavaSmtFormula comments
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
		1() from A to C; @False;  // Unsat -- A already committed to branch
	}	
	or
	{
		2() from A to B;
		2() from A to C;
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
		1() from B to C; @False;  // Unsat -- B has to follow A
	}	
	or
	{
		2() from A to B;
		2() from B to C;
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;  @False;
		1() from B to C;  @False;  // Sat because previous False makes implies to this one True
	}	
	or
	{
		2() from A to B;
		2() from B to C;
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	1(x:int) from B to A; @(x>4);
	choice at A
	{
		2() from A to B; @(x>6);  // Sat because of other case
		2() from B to C; @(x>5);  // Sat even though above was not sat, because assuming above then this is sat
		//2() from B to C; @(x>7);  // Uncomment is unsat
	}	
	or
	{
		3() from A to B;
		3() from B to C;
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
	}
	or
	{
		2() from A to B;
		do Proto2(A, B);
	}
}

global protocol Proto2(role A, role B)
{
	6() from B to A;
	choice at B
	{
		3() from B to A; //@False;  // TODO: try with "maybe" sat assrt here (with False after)
		4() from A to B; @False;
	}
	or
	{
		5() from B to A;
		do Proto2(A, B);
	}
}
//*/


/*
global protocol Proto1(role A, role B) @(x=1);
{
	1(y:int) from A to B; @(y>3);
	do Proto1(A, B); @y;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A to B;	
	do Proto2(A, B); @4;
}

global protocol Proto2(role A, role B) @(x=3);  // Unsat if validated as root 
{
	2(y:int) from B to A;  @(x>3);

	//do Proto2(A, B); @5;  // Sat
	//do Proto2(A, B); @3;  // Uncomment makes Proto1 unsat
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A to B;
	do Proto2(A, B); @4;
}

global protocol Proto2(role A, role B) @(x=3);  // Unsat if validated as root
{
	2() from B to A; @(x=4);
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B; 

	//2() from B to A; @(x>0);  // Unsat -- should be unsat
	
	choice at B
	{
		2() from B to A; @(x>0);  // Sat because of other choice branch
	}		
	or  // Unsat if case commented
	{
		3() from B to A;
	}
}
//*/


/*
global protocol Proto1(role A, role B) @(z=0);
{
	1(x:int) from A to B; @((x=z) && (x=0));
	//2(y:int) from B to A; @(y>x);

	//do Proto1(A, B);  @0;
	do Proto1(A, B);  @1;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B; @(x=1);
	2(y:int) from B to A; @(y>x);
	do Proto1(A, B);  // N.B. final receive formal at A doesn't get built at A
}
//*/


/*
global protocol Proto1(role B, role S) @(x=3);
{
	1(y:int) from B to S; @(y>3);
	choice at S
	{
		//2(z:int) from S to B; @((z>y) &&(y>3));

		//2() from S to B; @(y>x);
		2() from S to B; @(y>5);  // Unsat

		do Proto1(B, S); @y;
	}
	or
	{
		4() from S to B;
	}
}
/*/


/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B; @(x=1);	
	2(y:int) from A to B; @((y=2) && (y=(x+1)));	
	3(z:int) from A to B; @((z=3) && (z=(y+1)));	
}
//*/


/*
global protocol Proto1(role A, role B) @(x=3);
{
	1() from A to B; @(x>2);	

	do Proto1(A, B); @3;
	//do Proto1(A, B); @(3+1);

	//do Proto1(A, B); @x;  // Unsat -- cf. DbC? -- DbC it wouldn't be "x", it would "already" be 3 from substitution
			// Note, Proto1 could be called from "any context", so x can really be anything
	//do Proto1(A, B); @(x+1);  // Unsat
	//do Proto1(A, B); @(x-1);  // Unsat -- should be unsat
}
//*/


/*
global protocol Proto1(//role A,
		role B, role C)
{
	//RES(y:int) from A to B;
	RES(z3:int) from B to C; 
	RES(z4:int) from B to C; @(z4 = z3);
	
	//Using and: (forall ((z3 Int) (_x1 Int)) (and (= _x1 0) (exists ((z4 Int)) (= z4 z3)))) -- unsat forall x1 . x1 = 0
}
//*/


/*
global protocol Proto1(role A, role B) @(x=1);
{
	1(y:int) from A to B; @((y=x) && (x=1));

	do Proto1(A, B); @1;
	//do Proto1(A, B); @(x+1);  // Unsat -- cf. DbC?
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B; @(x=3);
	2(y:int) from A to B; @(y>x);
	
	do Proto1(A, B);
}
//*/


/*
global protocol Proto1(role A, role B) @(x=3);
{
	1(y:int) from A to B; @(y = x);
	2(z:int) from A to B; @(z = x);
}
//*/


/*
global protocol Proto1(role A, role B) @(x=3);
{
	choice at A
	{
		1(int) from A to B;
		do Proto1(A, B); @4;
	}
	or
	{
		2(int) from A to B;
		do Proto1(A, B); @3;
	}	

		//1(y:int) from A to B; @(x=4);

		//1(y:int) from A to B; @((y=4) && (x=y));
		
		//1(y:int) from A to B; @(x=y);


		//do Proto1(A, B); @3;
}
//*/


/*
//explicit 
global protocol Proto1(role A, role B) @(x=3);
{
	//1() connect A to B;
	2(y:int) from A to B; @(y=4);
	//3(z:int) from B to A; @((z=y) && (z=x));
	3(z:int) from B to A; @((z=y) && (z>x));
	
	do Proto1(A, B); @4;
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	1(x: int) from A to B; @(x > 6);

	//2(y: int) from B to A; @((y > x) && (y > 5));  // X
	//2(y: int) from B to A; @(y < x);  // X
	//2(y: int) from B to A; @(y = x);

	2(y: int) from B to A; @(y < 5);

	//3(z: int) from A to C; @(z < y);  // X
	//3(z: int) from A to C; @(z = y);  // X

	3(z: int) from A to C; @(z < 4);
}
//*/


/*
global protocol Proto1(role A, role B)
{
	rec X
	{
		choice at A
		{
			1(x:int) from A to B; @(x < 10);
			continue X;
		}
		or
		{
			2(y:int) from A to B; @(y > 5);
			continue X;
		}
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;	@(True && ((x+1) > 1));
	2(y:int) from A to B; @((y > 1) && (y = x));  // Not sat: x=1
}
//*/

/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{	
		1(int) from A to B;
		4(int) from A to C;
	}
	or
	{
		2(int) from A to B;
		3(int) from A to C;
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	choice at A
	{	
		1(x:int) from A to B;
		choice at A
		{
			2(y:int) from A to B;
			do Proto1(A, B);
		}
		or
		{
			3(z:int) from A to B;
		}
	
	}
	or
	{
		2(int) from A to B;
	}
}
//*/







/*
global protocol Proto1(role A, role B)
{
	choice at A
	{
		1(x:int) from A to B;
	}
	or
	{
		2(y:int) from A to B;
	}
	2(z:int) from A to B; 
	//2(y:int) from A to B;  // Uncomment is bad
}
//*/


/*
global protocol Proto1(role A, role B, role C, role D)
{
	1(x:int) from A to B;
	2(x:int) from C to D;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;
	2(x:int) from B to A;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;
	2(x:int) from A to B;
}
//*/


//---


/*
global protocol Proto1(role A, role B)
{
	(y:int) from A to C;
	(x:int) from A to B;
	[x=y]
	(x) from A to B;
	[x=y]
	(x) from A to B;

	(x:int) from A to B;
	(x) from A to B;

	(x:int) from A to B;
	(x) from B to A;
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	/*rec X
	{* /
		choice at A
		{
			1(y:int) from A to B;
			1(x:int) from B to C;
			//continue X;
		}
		or
		{
			2(y:int) from A to B;
			2(int) from B to C;
			2(x:int) from B to A;
		}
	//}
	[z=x]
	3(z:int) from B to A;  // In one case A knows x already, the other not
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1(y:int) from A to B;
		1(x:int) from B to C;
		//continue X;
	}
	or
	{
		2(x:int) from A to B;
		2(int) from B to C;
	}
	3(x) from B to C;  // CHECKME: One case B knows as receiver, the other as sender
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	rec X
	{
		choice at A
		{
			1(y:int) from A to B;
			1(x:int) from B to C;
			continue X;
		}
		or
		{
			2(y:int) from A to B;
			2(x:int) from B to C;
		}
	}
	3(x) from B to C;
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	rec X
	{
		choice at A
		{
			1(y:int) from A to B;
			1(x:int) from B to C;
			//continue X;
		}
		or
		{
			2(y:int) from A to B;
			2(x:int) from B to C;
		}
	}
	3(x) from B to C;
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
		choice at A
		{
			1(y:int) from A to B;
			1(x:int) from B to C;
		}
		or
		{
			2(y:int) from A to B;
			2(x:int) from B to C;
		}
	3(x) from B to C;
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1(y:int) from A to B;
		1(x:int) from B to C;
		//continue X;
	}
	or
	{
		2(y:int) from A to B;
		2(z:int) from B to C;
	}
	3(y) from A to B;
	//3(x) from A to B;  // Uncomment is bad
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1(y:int) from A to B;
		1(x:int) from B to C;
	}
	3(y) from A to B;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	rec X
	{
		1(x:int) from A to B;
	}
	2(x) from B to A;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	choice at A
	{
		1(x:int) from A to B;
	}
	or
	{
		2(y:int) from A to B;
	}
	3(y) from B to A;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;
	2(x) from B to A;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;
	2(x) from A to B;

}

//*/