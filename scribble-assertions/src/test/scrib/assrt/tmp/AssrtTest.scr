//Raymond@HZHL3 ~/code/eclipse/scribble/github.com/rumineykova/scribble-java
//$ bin/scribblec-assrt.sh -ip scribble-assertions/src/test/scrib/ -d scribble-assertions/src/test/scrib/ scribble-assertions/src/test/scrib/assrt/tmp/AssrtTest.scr 


// http://sandbox.kidstrythisathome.com/erdos/


module assrt.tmp.AssrtTest;


type <dotnet> "System.UInt32" from "..." as int;
type <dotnet> "System.String" from "..." as str;


// FIXME: debug printing for assertion passes


// - assertion validation
// - receive assertions -- why receive assertions?  should WF imply receive assertions always true?
// - explicit connections

//	.. rename connect to request
//	.. refactor a GConnectionAction (cf. LConnectionAction)

// .. need to update SubprotocolSig and "cycle" detection for protocoldecl/do annots? -- protocol inlining/unfolding with annots/assertions
// .. how about "syntactic" reachability check with protocoldecl/do annots?

// - recursion annotations
// - port forwarding annotations/assertions
// - arrays? -- cf. dependent types for array/list lengths -- https://www.reddit.com/r/fsharp/comments/28bbsr/faking_dependent_types_in_f/

// redo inlining/unfolding via model building? role/param/assert all in model states?


//*
//explicit 
global protocol Proto1(role A, role B) @(x=3);
{
	//1() connect A to B;
	2(y:int) from A to B; @(y=4);
	//3(z:int) from B to A; @((z=y) && (z=x));
	3(z:int) from B to A; @((z=y) && (z>x));
	
	do Proto1(A, B); @4;
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	1(x: int) from A to B; @(x > 6);

	//2(y: int) from B to A; @((y > x) && (y > 5));  // X
	//2(y: int) from B to A; @(y < x);  // X
	//2(y: int) from B to A; @(y = x);

	2(y: int) from B to A; @(y < 5);

	//3(z: int) from A to C; @(z < y);  // X
	//3(z: int) from A to C; @(z = y);  // X

	3(z: int) from A to C; @(z < 4);
}
//*/


/*
global protocol Proto1(role A, role B)
{
	rec X
	{
		choice at A
		{
			1(x:int) from A to B; @(x < 10);
			continue X;
		}
		or
		{
			2(y:int) from A to B; @(y > 5);
			continue X;
		}
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;	@(True && ((x+1) > 1));
	2(y:int) from A to B; @((y > 1) && (y = x));  // Not sat: x=1
}
//*/

/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{	
		1(int) from A to B;
		4(int) from A to C;
	}
	or
	{
		2(int) from A to B;
		3(int) from A to C;
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	choice at A
	{	
		1(x:int) from A to B;
		choice at A
		{
			2(y:int) from A to B;
			do Proto1(A, B);
		}
		or
		{
			3(z:int) from A to B;
		}
	
	}
	or
	{
		2(int) from A to B;
	}
}
//*/







/*
global protocol Proto1(role A, role B)
{
	choice at A
	{
		1(x:int) from A to B;
	}
	or
	{
		2(y:int) from A to B;
	}
	2(z:int) from A to B; 
	//2(y:int) from A to B;  // Uncomment is bad
}
//*/


/*
global protocol Proto1(role A, role B, role C, role D)
{
	1(x:int) from A to B;
	2(x:int) from C to D;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;
	2(x:int) from B to A;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;
	2(x:int) from A to B;
}
//*/


//---


/*
global protocol Proto1(role A, role B)
{
	(y:int) from A to C;
	(x:int) from A to B;
	[x=y]
	(x) from A to B;
	[x=y]
	(x) from A to B;

	(x:int) from A to B;
	(x) from A to B;

	(x:int) from A to B;
	(x) from B to A;
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	/*rec X
	{* /
		choice at A
		{
			1(y:int) from A to B;
			1(x:int) from B to C;
			//continue X;
		}
		or
		{
			2(y:int) from A to B;
			2(int) from B to C;
			2(x:int) from B to A;
		}
	//}
	[z=x]
	3(z:int) from B to A;  // In one case A knows x already, the other not
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1(y:int) from A to B;
		1(x:int) from B to C;
		//continue X;
	}
	or
	{
		2(x:int) from A to B;
		2(int) from B to C;
	}
	3(x) from B to C;  // CHECKME: One case B knows as receiver, the other as sender
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	rec X
	{
		choice at A
		{
			1(y:int) from A to B;
			1(x:int) from B to C;
			continue X;
		}
		or
		{
			2(y:int) from A to B;
			2(x:int) from B to C;
		}
	}
	3(x) from B to C;
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	rec X
	{
		choice at A
		{
			1(y:int) from A to B;
			1(x:int) from B to C;
			//continue X;
		}
		or
		{
			2(y:int) from A to B;
			2(x:int) from B to C;
		}
	}
	3(x) from B to C;
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
		choice at A
		{
			1(y:int) from A to B;
			1(x:int) from B to C;
		}
		or
		{
			2(y:int) from A to B;
			2(x:int) from B to C;
		}
	3(x) from B to C;
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1(y:int) from A to B;
		1(x:int) from B to C;
		//continue X;
	}
	or
	{
		2(y:int) from A to B;
		2(z:int) from B to C;
	}
	3(y) from A to B;
	//3(x) from A to B;  // Uncomment is bad
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1(y:int) from A to B;
		1(x:int) from B to C;
	}
	3(y) from A to B;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	rec X
	{
		1(x:int) from A to B;
	}
	2(x) from B to A;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	choice at A
	{
		1(x:int) from A to B;
	}
	or
	{
		2(y:int) from A to B;
	}
	3(y) from B to A;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;
	2(x) from B to A;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;
	2(x) from A to B;

}

//*/