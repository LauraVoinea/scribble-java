//$ bin/scribblec-assrt.sh -ip scribble-assertions/src/test/scrib/ -d scribble-assertions/src/test/scrib/ scribble-assertions/src/test/scrib/assrt/tmp/AssrtTest.scr -fair -assrt -z3 -batch -modelpng Proto1 Proto1.png -fsmpng Proto1 A Proto1_A.png -fsmpng Proto1 B Proto1_B.png

//$ bin/scribblec-assrt.sh -ip scribble-assertions/src/test/scrib/ -d scribble-assertions/src/test/scrib/ -fair -assrt -z3 -batch c:/Users/rhu/myroot/home/rhu1/code/docker/fluidsess-dev/opam/scribbler/fluidsess/github.com/rhu1/fluidsess-examples/oopsla20/Adder/Adder.scr


module assrt.tmp.AssrtTest;


type <fstar> "int" from "..." as int;
//type <fstar> "string" from "..." as string;  // !!! Z3 needs "String"
type <fstar> "string" from "..." as String;



// HERE
// 0. merge rhu1-refactorinterfaces
// 1. test examples and unit tests
// 2. integrate with artifact
// 3. do global type LTS and validation
// 4. dynamic test global-local correspondence
// - derived LTS should fully replace base LTS recursion rules -- then do silent squashing on top
// !!! FIXME: duplicate located statevars not checked, e.g., A[y:int=0] B[y:int=0]


/*
global protocol Proto1(role A, role B) @'A[n:int = 0, m:int = 1]' {
    1() from A to B;
    do Proto1(A, B); @'A[0, m]'
}
//*/


// HERE HERE more testing of sessionstar example RCAs -> tempRunSyncSat global validation (check status of global LTS)

// HERE HERE move all lambdas to silents on concretes and start from blank lambda -- cf. ff and flatten?
//({x=(ZERO, int)}, B?{ 4(y1:int){True}.end, 5(y2:int){True}.end })
//({z1=(ZERO, int)}, B?:3(z2:int){True}.end)




global protocol Proto1(role A, role B, role C) {
    choice at A {
        1(x: int) from A to B;  @'x>0'
        2(y: int) from B to C;  @'y>x'
        do Proto1(A, B, C);
    } or {
        3(z1: int) from A to B;  @'z1<=0'
        4(z2: int) from B to C;  @'z2<z1'
    }
}




/*
global protocol Proto1(role A, role B, role C) {
    choice at A {
        1(x: int) from A to B;
        choice at B {
            4(y1: int) from B to C;  @'y1=x'  // Refactor init lambda (x) to init edges necessary in flattening
            do Proto1(A, B, C);
        } or {
            5(y2: int) from B to C;
            do Proto1(A, B, C);
        }
    } or {
        2(z1: int) from A to B;
        3(z2: int) from B to C;
    }
}
//*/

/*
global protocol Proto1(role A, role B, role C) {
    choice at A {
        1(x: int) from A to B;
        choice at B {
            4(y1: int) from B to C;  // Testing flattening
        } or {
            5(y2: int) from B to C;
        }
    } or {
        2(z1: int) from A to B;
        3(z2: int) from B to C;
    }
}
//*/


/*
global protocol Proto1(role A, role B, role C, role D) {

    // !!! A->B.C->D != C->D.A->B ? -- because of phantom knowledge

    Fst(x: int) from A to B;
    Snd(y: int) from B to C;   //@'x = y'
    Trd(z : int) from C to D;  @'x = z'
}
//*/


/*
global protocol Proto1(role A, role B, role C) {
  start(n:int) from A to B;  @'0<=n && n<100'
  limit(t:int) from A to B;  @'t>0'
  do HLLimitAux(A, B, C);     @'B[n, t]'
}

aux global protocol HLLimitAux(role A, role B, role C)
        @'B[n1: int = 0, t1: int = 1] 0<=n1 && n1<100 && t1>0' {
  guess(x:int) from C to B;  @'0<=x && x<100'  // Added this refinement
  choice at B {
    higher() from B to C;    @'n1>x && t1>1'
    higher() from B to A;
    do HLLimitAux(A, B, C);   @'B[n1, t1-1]'
  } or {
    win() from B to C;       @'n1=x'
    lose() from B to A;
  } or {
    lose() from B to C;      //@'(!(n1=x)) && t1=1'  // FIXME: ! precedence
                             @'((n1<x || n1>x) && t1=1)'
    win() from B to A;
  } or {
    lower() from B to C;     @'n1<x && t1>1'
    lower() from B to A;
    do HLLimitAux(A, B, C);   @'B[n1, t1-1]'
  }
}
//*/




/*
global protocol MyProto(role A, role B, role C) {
  start(n:int) from A to B;  @'0<=n && n<100'
  do HigherLowerAux(A, B, C);     @'B[n]'
}

aux global protocol HigherLowerAux(role A, role B, role C) @'B[n1: int = 0]' {
  guess(x:int) from C to B;  // TODO: add guess refinement
  guess(z:int) from C to A;
  choice at B {
    higher() from B to C;   @'n1>x'
    higher() from B to A;
    do HigherLowerAux(A, B, C);  @'B[n1]'
  } or {
    win() from B to C;      @'n1=x'
    win() from B to A;
  } or {
    lower() from B to C;    @'n1<x'
    lower() from B to A;
    do HigherLowerAux(A, B, C);  @'B[n1]'
  }
}
//*/

/*
global protocol MyProto(role A, role B) {
    1(z: int) from A to B;  @'z=0'
    do MyAux(A, B);       @'[42]'  // HERE resolved? // !!! TODO 42 should be phantom for B -- handle in projection/estepper? B label should be silent rec enter -- cf. AssrtFormalLRec.getIntermedSteppable
}

aux global protocol MyAux(role A, role B) @'A[y:int=41]' {
    2(x: int) from A to B;  @'x=-1'
    do MyAux(A, B);       @'[y]'
}
//*/


/*// !!! Scribble has "global" statevars @'[y:int=0]' and "located" A[yA:int=0] B[yB:int=0]
global protocol MyProto(role A, role B) @'A[yA:int=0] B[yB:int=0]' {
    1(x: int) from A to B;  @'x=0'
    do MyProto(A, B);       @'[yB, yA]'  // !!! TODO CHECKME bad knowledge
}
//*/


/*
global protocol MyProto(role A, role B, role C) {
    1(x: int) from A to B;  @'x=0'
    choice at B {
        2(y: int) from B to C;  @'y=x'
        3(z: int) from C to A;  @'z=y'
    } or {
        4(yy: int) from B to C;  @'yy=x'
        5(zz: int) from C to A;  @'zz=yy'
    }
}
//*/

/*
global protocol MyProto(role A, role B, role C) {
    1(x: int) from A to B;  @'x=0'
    2(y: int) from B to C;  @'y=x'
    3(z: int) from C to A;  @'z=y'
}
//*/

/*
global protocol MyProto(role A, role B) {
    1(x: int) from a to b;  @'x=0'
    2(y: int) from b to a;  @'y=x'
}
//*/


/*
//global protocol MyProto(role A, role B, role C) {
global protocol MyProto(role A, role B) {
    //Foo(x: int) from A to C;  @'x>0'
    0(x: int) from B to A;  @'x>0'
    choice at A {
        1() from A to B;  @'x>1'
        do MyProto(A, B);
    } or {
        2() from A to B;  @'x<=1'
        do MyProto(A, B);
    }

    /*1(x: int) from A to B;
    2(y: int) from B to C;  @'x=y'
    3(z: int) from C to B;  @'z=x'* /

    /*1(x: int) from A to B;  @'x>0'
    do MyProto(A, B);* /
}
//*/

/*
global protocol MyProto(role A, role B) {
    1(x0: int) from A to B;
    do Aux(A, B);  @'B[x0]'
    }
aux global protocol Aux(role A, role B) @'B[x: int = 0]' {
    choice at B {
        2() from B to A;  @'x>0'
        do Aux(A, B);  @'B[x]'
    } or {
        3() from B to A;  @'x<=0'
    }
}
//*/

/*
global protocol MyProto(role A, role B) {
    /*1(x: int) from A to B;  @'x>0'
    2(y: int) from B to C;  @'y<x'  // !!! not implementable -- "knowledge check" disabled for phantoms -- cf. DbC HS?
    3(z: int) from C to A;  @'z>x'* /



    0(x: int) from A to B; @'!(x=0)'
    choice at A {
        1() from A to B; @'x < 0'
    } or {
        2() from A to B;
    } or {
        3() from A to B; @'x=0'
    }
}
//*/






/*
global protocol MyProto(role A, role B, role C) {
    1(x: int) from A to B;  @'x>0'
    2(y: int) from B to C;  @'y>x'
    3(z: int) from C to A;  @'z>x'  // a.k.a. phantom hello world -- how to static validate? ...good implementation: is z>y (=> z>x) -- cf. "subtyping"?
}
//*/

/*
global protocol MyProto(role A, role B, role C) {
    choice at A {
        1() from A to B;
        2() from A to C;
        do MyProto(A, B, C);
    } or {
        3() from A to B;
        4() from A to C;
    }
}
//*/

/*
global protocol MyProto(role A, role B, role C, role D, role E) {
    1(x: int) from A to B;
    2(y: int) from C to D;  // TODO Add utest
    3(z: int) from B to E;
}
//*/

/*
//global protocol MyProto(role A, role B, role C, role D) {
global protocol MyProto(role A, role B) {
    //foo() from C to D;
    choice at A {
        1() from A to B;
        2() from B to A;
        do MyProto(A, B);
    } or {
        3() from A to B;
        4() from B to A;
    }
}
//*/
















/*global protocol MyProto(role A, role B) {
	choice at A
	{
		Mul(x: int, y: int) from A to B;
		Res(z: int) from B to A;  @'z = x * y'
	}
	or
	{
		Bye() from A to B;
	}
}
//*/


/*
global protocol MyProto(role A, role B) {
	//1() from A to B;  @'3 > (2 * 1)'  // TODO: add test?
	1(x: int) from A to B;  @'x > (3 * 2)'
}
//*/


/*
global protocol MyProto(role A, role B) {
	//1(x: int) from A to B;  @'!False'
	//1(x: int) from A to B;  @'(x > (1+1)) && True'
	//1(x: int) from A to B;  @'x > (1+1)'
	//1(x: int) from A to B;  @'(!False) || True'
	1(x: int) from A to B;  @'!False || True'
	//1(x: int) from A to B;  @'!0 > 1'
}
//*/











/*
global protocol Test(role A, role B) {
  choice at A {
    do Foo(A, B); @'A[0]'
  } or {
    do Bar(A, B); @'A[1]'
  }
}

aux global protocol Foo(role A, role B) @'A[x: int = 0]' {
  Foo() from A to B;
  do Foo(A, B); @'A[1]'
}

aux global protocol Bar(role A, role B) @'A[y: int = 1]' {
  Bar() from A to B;
  do Bar(A, B); @'A[0]'
}
//*/














/*global protocol MyProto(role A, role B, role C) {
	choice at A {
		1(x: int) from A to B;  @'x>0'
		2() from A to C;
	} or {
		3() from A to B;
		//2() from A to C;
		4() from A to C;
	}
}
//*/




/*
global protocol MyProto(role A, role B) {
	choice at A {
		1() from B to A;  // Testing merge, mixed action kinds
	}
}
//*/


/*
global protocol MyProto(role A, role B, role C) {
	choice at A {
		1() from A to B;
		// Testing, merge with "missing" cases
		3() from A to C;
		//2() from A to C;  // Testing merge, duplicate labels (regardless of continuation equal or not)
	} or {
		2() from A to B;
		//2() from C to A;  // Testing merge, mixed action kinds
		2() from A to C;
	}
}
//*





/*
global protocol MyProto(role A, role B, role C) {
    1(x1: int) from A to B;        @'x1>0'
    2(x2: int) from A to C;        @'x2=x1'j
    do MyProtoAux(A, B, C);        @'B[x1] C[x2]'
}

aux global protocol MyProtoAux(role A, role B, role C)
                                   @'B[xB: int = 0] C[xC: int = 0] xB>=0' {
    choice at B {
        2(curr: int) from B to C;  @'xB>0 && curr=xB'
        3(orig: int) from C to A;  @'orig=xC'
        do MyProtoAux(A, B, C);    @'B[xB-1] C[xC]'
    } or {
        Bye() from B to C;         @'xB=0'
        Bye() from C to A;
    }
}
//*/



/*
global protocol Proto1(role A, role B) @'[x: int = 0]' {
	1() from A to B;
	//do Proto1(A, B);  // Testing do arg checking
	do Proto1(A, B);  @'[1, 1]'  // Testing do arg checking
}
//*/





/*
global protocol Proto1(role A, role B) @'B[z: int = 1] y>0' {  // Testing unknown variable
	1() from A to B;
}
//*/



/*
global protocol Proto1(role A, role B) @"B[z: int = 1] z>0"
{
	1(y: int) from A to B;  @'y<0 && y>z'  // Violation detected -- correct: z>0 is globally known assertion
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A to B;
	do Proto1Aux(A, B);  @'A[2]'
}

aux global protocol Proto1Aux(role A, role B) @"A[z1: int = 1] z1>0"  // N.B. statevars, phantoms with only two roles
{
	2(y: int) from B to A;  @'y = z1'
			// TODO: separate phantoms explicitly in model ("variable" and assertion known, but "value" unknown) -- issue of (phantom) statevars (vs. payvars) is initialiser expr
			// Currently allowed ( phantom statevars globally known by default), but unimplementable in F* (z1 value at B unknown, refinement can't be proved)
}
//*/





/*
global protocol Proto1(role A, role B)
{
	1(x: int) from A to B;
	choice at B
	{
		2() from B to A;  @'x>0'  // s* progress comes from output callback return type, i.e., "completeness" of return value construction
	}
	or
	{
		3() from B to A;  @'x<0'
	}
}
//*/




/*
global protocol Proto1(role A, role B, role C)
{
	1(x: int) from A to B;  @'x>0'
	0() from B to C;  // Comment is bad: C!A would be from initial state (bad is debatable? "statically extract" phantom knowledge? -- but knowledge should still depend on choice?)
	// As is, x phantom added (via projection) to B!C message
	2(y: int) from C to A;
			//@'y=x'
			@'x>0'
}
//*/



/*global protocol Proto1(role A, role B) @"[z: int = 3]"
{
	1(x:int) from A to B; @"(x=3)"
	2(y:int) from A to B; @"(y>x)"
	do Proto1(A, B);
}
//*/



/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;
	//do Proto2(A, B);
	do Proto2(A, B); @"[x]"
}

aux global protocol Proto1Aux(role A, role B) @"[x1: int = -1]"  // N.B. x1
{
	2(y:int) from A to B; @"(y>x1)"
	do Proto1Aux(A, B);
}
//*/



/*
global protocol Proto1(role A, role B)  @'[x: int = 0]' {
	1() from A to B;
	do Proto1(A, B); @'[x]'
}
//*/


/*
global protocol Proto1(role A, role B)  @'A[x: int = 0]' {
	1() from A to B;
	2(y: int) from B to A;  @'y>x'  // CHECKME: OK for B to do that? -- not in general: cf. located statevar x=1, phantom x=0, pay assertion y=x (y picked by phantom guy)
}
//*/




/*
global protocol Proto1(role A, role B)
{
	1() from A to B;
	do Proto1Aux(A, B);  @'A[5]'
	//do Proto1Aux(A, B);  @'A[2]'
}

//aux global protocol Proto1Aux(role A, role B) @'A[x: int = 3] x>4'  // CHECKME: currently allowed
aux global protocol Proto1Aux(role A, role B) @'A[x: int = 5] x>4'
{
	2() from B to A;//  @'x=z'
}
//*/

/*
global protocol Proto1(role A, role B)
{
	1() from A to B;
	do Proto1Aux(A, B);  @'C[5]'
	//do Proto1Aux(A, B);  @'C[2]'  // Testing statevar role inlining substitution
}

aux global protocol Proto1Aux(role C, role B) @'C[x: int = 5] x>4'
{
	2() from B to C;//  @'x=z'
}
//*/





/*
global protocol Proto1(role A, role B)
{
	1() from A to B;
	do Proto1Aux(A, B);  @'A[2] B[0]'
	//do Proto1Aux(A, B);  @'B[0] A[2]'  // TODO: role annotations currently ignored -- only order matters
}

aux global protocol Proto1Aux(role A, role B) @'A[x: int = 3] B[y: int = 0] x>1'
{
	2() from B to A;//  @'x=z'
}
//*/



/*
global protocol Proto1(role A, role B)
{
	1() from A to B;
	do Proto1Aux(A, B);  @'D[1]'  // N.B. D, not B
}

aux global protocol Proto1Aux(role C, role D) @'D[x: int = 0]'
{
	2() from D to C;
}
//*/


/*
global protocol Proto1(role A, role B)  @'A[xa: int = 1]'  // Testing parser
//global protocol Proto1(role A, role B)  @'A[xa: int = 1] True'
//global protocol Proto1(role A, role B)  @'A[xa: int = 1] B[xb: int = 1] True'
//global protocol Proto1(role A, role B)  @'A[xa: int = 1] B[xb: int = 1]'
{
	1() from A to B; @'xa = 1'
}
//*/




/*
global protocol Proto1(role A, role B)  @'A[xa: String = 1]'  // TODO: statevars currently hardcoded to int
{
	1() from A to B; @'x1 = 1'
}
//*/


/*
//global protocol Proto1(role A, role B, role C) @'<x:A = 1, x:B = 1> x>0'  // Phantom statevar for C
//global protocol Proto1(role A, role B, role C)  @'A[x: int = 1] x>0'
//global protocol Proto1(role A, role B, role C)  @'A[x: int = 1] B[x: int = 1] x>0'  // TODO: test string sort (cf. AssrtForallIntVars: getSmt2VarDecl, env; toSmt2Sort)
		// TODO: disjoint varnames
global protocol Proto1(role A, role B, role C)  @'A[xa: int = 1] B[xb: int = 1] xa>0 && xb>0'
{
	//1(y: int) from A to B;  @'y>x'
	1(y: int) from A to B;  @'y>xa'
	2() from B to C;
	//do Proto1(A, B, C);  @'<1>'
	//do Proto1(A, B, C);  @'A[1]'
	do Proto1(A, B, C);  @'A[1] B[1]'  // TODO: record/use rolename -- currently, AssrtStateVarArgList directly stores AExprs (i.e., no sort or role)
}
//*/

/*
global protocol Proto1(role A, role B, role C) @'<x:A = 1, x:B = 2> x>0' {
	1(y: int) from A to B;  @'x=1'
	2() from B to C;
}
//*/

















/*
global protocol Proto1(role A, role B, role C)
{
 choice at A
 {
   Nat(x: int) from A to B; @"x>=0"
   Ok() from B to C;
 }
 or
 {
   Neg(y: int) from A to B; @"y<0"
   Ok() from B to C;
 }
}
//*/



/*
global protocol Proto1(role A, role B) {  // Cf. OnlineWallet
	0(b:int) from B to A;  @'b>=-100'
	do Proto1Aux(A, B);  @'<b, 100>'
}
aux global protocol Proto1Aux(role A, role B)  @'<balance:=0, overdraft:=0> balance>=(0-overdraft) && overdraft>=0' {
	1(x:int) from A to B;  @'0<=x && x<=(balance+overdraft)'
}
//*/

/*
global protocol Proto1(role A, role B) {
	0(b:int) from B to A;  @'b>=-100'
	do Proto1Aux(A, B);  @'<b, 100>'
}
aux global protocol Proto1Aux(role A, role B)  @'<balance:=0, overdraft:=0> balance>=(0-overdraft) && overdraft>=0' {
	choice at A {
		1(x:int) from A to B;  @'0<x && x<=(balance+overdraft)'
	} or {
		2() from A to B;
	}
}
//*/

/*
global protocol Proto1(role A, role B) {
	0(b:int) from B to A;  @'b>=-100'
	do Proto1Aux(A, B);    @'<b, 100>'
}
//aux global protocol Proto1Aux(role A, role B)  @'<balance=0, overdraft=0> balance>=(0-overdraft) && overdraft>=0' {
aux global protocol Proto1Aux(role A, role B)  @'<balance:B=0, overdraft:B=0> balance>=(0-overdraft) && overdraft>=0' {
	choice at A {
		1(x:int) from A to B;  @'0<x && x<=(balance+overdraft)'
		do Proto1Aux(A, B);    @'<balance-x, overdraft>'
	} or {
		2() from A to B;
	}
}
//*/

/*
global protocol Proto1(role A, role B) {  // Cf. OnlineWallet
	0(b:int) from B to A;  @'b>=-100'
	do Proto1Aux(A, B);    @'<b+100, b, 100>'
}
aux global protocol Proto1Aux(role A, role B)  // Testing exist quant phantom statevars in state assertions (allow w.r.t. C)
			@'<allow:A=100, balance:B=0, overdraft:B=100> allow=balance+overdraft && balance>=(0-overdraft) && overdraft>=0' {

	choice at A {
		1(x:int) from A to B;  @'0<x && x<=allow'
		do Proto1Aux(A, B);    @'<allow-x, balance-x, overdraft>'
	} or {
		2() from A to B;
	}
}
//*/





/*
global protocol Proto1(role A, role B, role C) {  // Bad
	1(x:int) from A to B;
	2(y:int) from C to B; @'y>x'  // CHECKME: x is phantom for C, despite no causality between A and C
	// ^but caught by async model checking, because K update is *post* condition of send
}
//*/






/*
global protocol Proto1(role A, role B, role C)
{
	//start(n0:int, t0:int) from A to B;  @'(0<=n0 && n0<100) && 0<t0'
	//do Aux(A, B, C);  @'<n0, t0>'
	do Aux(A, B, C);  @'<0, 1>'
}

aux global protocol Aux(role A, role B, role C) @'<n:B=0, t:B=1> (0 <= n && n < 100) && 0 < t'
//aux global protocol Aux(role A, role B, role C) @'B<n:int=0 (0 <= n && n < 100)> B<t:int=0 (0 < t)>'
//aux global protocol Aux(role A, role B, role C) @'B<n:int{0 <= n && n < 100}=0, t:int{0 < t}=0>'
{
	guess(x:int) from C to B;  @'0<=x && x<100'  // Next guess by C
	choice at B
	{
		higher() from B to C;  @'n>x && t>1'
		higher() from B to A;
		do Aux(A, B, C);  @'<n, t-1>'
	}
	or
	{
		foo() from B to C;
		foo() from B to A;  // Testing phantom assertion edges
	}
}
//*/

/*
global protocol Proto1(role A, role B, role C)
{
	start(n0:int, t0:int) from A to B;  @'(0<=n0 && n0<100) && 0<t0'
	do Aux(A, B, C);  @'<n0, t0>'
}

aux global protocol Aux(role A, role B, role C) @'<n:B=0, t:B=1> (0 <= n && n < 100) && 0 < t'
//aux global protocol Aux(role A, role B, role C) @'B<n:int=0 (0 <= n && n < 100)> B<t:int=0 (0 < t)>'
//aux global protocol Aux(role A, role B, role C) @'B<n:int{0 <= n && n < 100}=0, t:int{0 < t}=0>'
{
	guess(x:int) from C to B;  @'0<=x && x<100'  // Next guess by C
	choice at B
	{
		higher() from B to C;  @'n>x && t>1'
		higher() from B to A;
		do Aux(A, B, C);  @'<n, t-1>'
	}
	or
	{
		win() from B to C;  @'n=x'
		lose() from B to A;
	}
	or
	{
		lower() from B to C;  @'n<x && t>1'
		lower() from B to A;
		do Aux(A, B, C);  @'<n, t-1>'
	}
	or
	{
		lose() from B to C;  @'(!(n=x)) && t=1'
		win() from B to A;
	}
}
//*/





/*
global protocol OnlineWallet(role S, role C, role A) {
 login(id: String, pw: String) from C to A;
 choice at A {
   login_ok() from A to C;
   login_ok() from A to S;
   account(balance: int, overdraft: int) from S to C; @"balance>=0 && overdraft>=0"
   do Authenticated(S, C); @"<balance + overdraft>"
 } or {
   login_fail(error: String) from A to C;
   login_fail() from A to S;
 }
}

aux global protocol Authenticated(role S, role C) @"<allowance:C=0> allowance>=0" {
 choice at C {
   pay(payee: String, amount: int) from C to S; @"amount<=allowance"
   account(newbalance: int, newoverdraft: int) from S to C; @"newbalance>=0 && newoverdraft>=0"
   do Authenticated(S, C); @"<newbalance + newoverdraft>"
 } or {
   quit() from C to S;
 }
}
//*/


/*
global protocol Proto1(role A, role B, role C) {
  start(n:int) from A to B;  @'0<=n && n<100'
  limit(t:int) from A to B;  @'t>0'
  do Proto1Aux(A, B, C);     @'<n, t>'
}

aux global protocol Proto1Aux(role A, role B, role C) @'<n1:B=0, t1:B=1> t1>0' {
  guess(x:int) from C to B;  @'0<=x && x<100'  // Added this refinement
  choice at B {
    higher() from B to C;    @'n1>x && t1>1'
    higher() from B to A;
    do Proto1Aux(A, B, C);   @'<n1, t1-1>'
  } or {
    win() from B to C;       @'n1=x'
    lose() from B to A;
  } or {
    lose() from B to C;      //@'(!(n1=x)) && t1=1'  // FIXME: ! precedence
                             @'((n1<x || n1>x) && t1=1)'
    win() from B to A;
  } or {
    lower() from B to C;     @'n1<x && t1>1'
    lower() from B to A;
    do Proto1Aux(A, B, C);   @'<n1, t1-1>'
  }
}
//*/


/*
global protocol DbC(role Buyer, role Seller, role Bank) @"<pvo:=100>"
{
  offer(vo:int) from Buyer to Seller; @"vo >= 100"
  choice at Seller {
    hag() from Seller to Buyer; @"vo > pvo"
    do DbC(Buyer, Seller, Bank); @"<vo>"
  } or {
    ok() from Seller to Buyer;
    payment(vp:int) from Buyer to Bank; @"vo = vp"
    ack(va:bool) from Bank to Seller;
  }
}
//*/


/*
global protocol Proto1(role A, role B) @'<xA:A=1, xB:B=1>' {
	1() from A to B;
	do Proto1(A, B); @'<xA, xB>'
}
//*/


/*
global protocol Proto1(role A, role B) @'<xA:A=1, xB:B=1>' {
// Maybe don't need or shouldn't have "sync'd" state vars, i.e., keep all distributed (distinct var names)
// Rely on explicit payload vars -- comm'd will be know anyway, and can manually assign to statevar locally
// And since assertion depends on statevars, means statevar annots are "localised" one role per rec
// Basically, can nest recs anyway for multiple roles
	1() from A to B;
	do Proto1(A, B); @'<xA, xB>'
}
//*/


/*
global protocol Proto1(role A, role B) {
	1(x:int) from A to B;
	do Proto1(A, B); @'<x, x>'  // TODO: fix error
	do Proto1Aux(A, B); @'<x, x>'
}

aux global protocol Proto1Aux(role A, role B) @'<xA:A=1, xB:B=1>' {  // TODO drop init sexprs for aux statevars
	2() from B to A;
}
//*/


/*
global protocol Proto1(role A, role B, role C) {
	1(x:int) from A to B;  @'x>0'
	do Proto1Aux(A, B, C); @'<x, x>'
}

aux global protocol Proto1Aux(role A, role B, role C) @'<xA:A=1, xB:B=1> xB>0' {
	2() from B to A;
	2() from B to C;
}
//*/


/*
global protocol Proto1(role A, role B) @'<x:=1, y:=2> x>1 || y>1'
// Cannot do "fine-grained projection" of assertions onto located statevars
// TODO add bad test
{
	choice at A
	{
		1() from A to B; @'x>1'
	}
	or
	{
		2() from A to B;
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C) {
  1(x:int) from A to B;    @'x>5'
  do Proto1Aux(A, B, C);   @'<x>'  // TODO: check x is known by B (target located statevar)
}

aux global protocol Proto1Aux(role A, role B, role C) @'<x1:B=1> x1>0' {
  2() from C to B;  // TODO: add bad test -- x1 globally inlined to x is incorrect for C (C doesn't know x)
  3() from C to A;  //@'x>0 && x<2'  // Cannot have mixed init of statevar, e.g., from message for located, from default for nonlocated, inconsistent -- quantify? (phantom?)  // TODO add bad test
}
//*/


/*
global protocol Proto1(role A, role B)
{
	//1() from A to B;
	do Proto1Aux(A, B); @'<2>'
}

aux global protocol Proto1Aux(role A, role B) @"<y:=1>"  // CHECKME: batch is failing, but default is passing -- no: it's because the "new" ass-unsat works this way (cf. AssrtCoreSModel)
{
	choice at B
	{
		2() from B to A; //@'y>1'
	  do Proto1Aux(A, B); @'<y-1>'
	}
	or
	{
	  3() from B to A; @'y<=1'  // initial (i.e., original) ass-unsat fails because y:=1
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C) {
  start(n:int) from A to B;  @'0<=n && n<100'
  limit(t:int) from A to B;  @'t>0'
  do Proto1Aux(A, B, C);     @'<n, t>'
}

aux global protocol Proto1Aux(role A, role B, role C) @'<n1:B=0, t1:B=1> t1>0' {
  guess(x:int) from C to B;
  choice at B {
    higher() from B to C;   @'n1>x && t1>1'
    higher() from B to A;
    do Proto1Aux(A, B, C);  @'<n1, t1-1>'
  } or {
    win() from B to C;      @'n1=x'
    lose() from B to A;
  } or {
    lose() from B to C;     @'(!(n1=x)) && t1=1'  // FIXME: ! precedence
    win() from B to A;
  } or {
    lower() from B to C;    @'n1<x && t1>1'
    lower() from B to A;
    do Proto1Aux(A, B, C);  @'<n1, t1-1>'
  }
}
//*/


/*
global protocol Proto1(role A, role B, role C) {
  start(n:int) from A to B;  @'0<=n && n<100'
  limit(t:int) from A to B;  @'t>0'
  do Proto1Aux(A, B, C);     @'<n, n, t>'
}

aux global protocol Proto1Aux(role A, role B, role C) @'<nA:A=0, n1:B=0, t1:B=1> t1>0' {
  guess(x:int) from C to B;
  guess() from C to A;
  choice at B {
    higher() from B to C;   @'n1>x && t1>1'
    higher() from B to A;
    do Proto1Aux(A, B, C);  @'<nA, n1, t1-1>'
  } or {
    win() from B to C;      @'n1=x'
    lose() from B to A;
  } or {
    lose() from B to C;     @'!(n1=x) && t1=1'
    win() from B to A;
  } or {
    lower() from B to C;    @'n1<x && t1>1'
    lower() from B to A;
    do Proto1Aux(A, B, C);  @'<nA, n1, t1-1>'
  }
}
//*/


/*
global protocol Proto1(role A, role B, role C) {
  start(n:int) from A to B;     @'0<=n && n<100'
  limit(t:int) from A to B;     @'t>0'
  guess(x:int) from C to B;
  do Proto1Aux(A, B, C);        @'<n, t, x, x>'
}

aux global protocol Proto1Aux(role A, role B, role C)
                                @'<n1:B=0, t1:B=0, xB:B=0, xC:C=0> t1>=0' {
  choice at B {
    higher() from B to C;       @'n1>xB && t1>0'
    higher() from B to A;
    guess(x2:int) from C to B;  @'x2>xC'
    do Proto1Aux(A, B, C);      @'<n1, t1-1, x2, x2>'
  } or {
    win() from B to C;          @'n1=xB'
    lose() from B to A;
  } or {
    lose() from B to C;         @'(!(n1=xB)) && t1=0'  // FIXME: ! precedence
    win() from B to A;
  } or {
    lower() from B to C;        @'n1<xB && t1>0'
    lower() from B to A;
    guess(x3:int) from C to B;  @'x3<xC'
    do Proto1Aux(A, B, C);      @'<n1, t1-1, x3, x3>'
  }
}
//*/


/*  // TODO z3 bitvec
global protocol Proto1(role A, role B) @'<x:=0>' {
	1(y:int) from A to B;  @'...'
}
*/



































/*
global protocol Proto1(role A, role B, role C) {
  num(x:int) from A to B;
  limit(z:int) from A to B;
  do Proto1Aux(A, B, C); @'<x, z>'
}

aux global protocol Proto1Aux(role A, role B, role C) @'<x1:=0, z1:=0>' {
  guess(y:int) from C to B;
  choice at B {
    toohigh() from B to C;     @'y>x1'
    conthigh() from B to A;
    do Proto1Aux(A, B, C);  @'<x1, z1-1>'
  } or {
    win() from B to C;         @'y=x1 && z1>0'
    lose() from B to A;
  } or {
    lose() from B to C;        @'z1<=0'
    win() from B to A;
  } or {
    toolow() from B to C;      @'y<x1'
    contlow() from B to A;
    do Proto1Aux(A, B, C);  @'<x1,z1-1>'
  }
}
//*/


/*
global protocol Proto1(role A, role B) @"<y:=0, x:=50>"
{
	choice at A
	{
		1() from A to B;
		do Proto1(A, B); @"<y, x+1>"
	}
	or
	{
		i2() from A to B;
		do Proto1(A, B); @"<y, x-1>"
	}
}
//*/

/*
global protocol Proto1(role A, role B, role C)
{
	1() from A to B;
	do Proto1Aux(B, C);
}

aux global protocol Proto1Aux(role B, role C)
{
	2() from C to B;
  choice at B
  {
  	3() from B to C;
  	do Proto1Aux(B, C);
  }
  or
  {
  	4() from B to C;
  }
}
//*/


/*
global protocol Proto1(role A, role B) @'<x:=0>' {
	1(x1:int) from A to B;  @'x1>=x'
	do Proto1Aux(A, B);  @'<x1>'
}

aux global protocol Proto1Aux(role A, role B) @'<y:=0> y>=0' {
//aux global protocol Proto1Aux(role A, role B) @'<y:=0> y>=1' {
	2(y1:int) from B to A;  @'y1>y'
}
//*/


// - rename intvar
// - remove disamb






/*
global protocol Proto1(role A, role B, role C) @'<x:=0>' {
	choice at A {
		1() from A to B;  @'x=0'
		1() from B to C;	@'x=0'  // Shows "global statevar" exprs must be statically fixed (not locally/dynamically set)
	} or {
		2() from A to B;  //@'x=1'
		2() from B to C;	//@'x=1'
	}
}
//*/







/*  // Testing statevar WF -- init exprs (constants)
global protocol Proto1(role A, role B) @'<x:=0>' {
	1() from A to B;  @'x=0'
	//1() from A to B;  @'x=1'  // Bad
}
//*/


/*  // Testing statevar WF -- loop counting
//global protocol Proto1(role A, role B) @'<x:=0>' {
//global protocol Proto1(role A, role B) @'<x:=0> x >= 0' {
global protocol Proto1(role A, role B) @'<x:=0> x >= 0 && x <= 5' {  // TODO: add tests
//global protocol Proto1(role A, role B) @'<x:=0> x >= 0 && x < 5' {  // Bad
	choice at A {
		1() from A to B;  @'x<5'
		do Proto1(A, B);  @'<x+1>'
	} or {
		2() from A to B;  @'x>=5'
		//2() from A to B;  @'x=5'  // CHECKME: not allowed, not assrt-prog for _x case
	}
}
//*/


/*  // Testing statevar WF -- loop counting
//global protocol Proto1(role A, role B) @'<x:=0>' {  // 2()@x>=5 not caught as unsat (without any statevar ass)
global protocol Proto1(role A, role B) @'<x:=0> x >= 0' {  // Bad (as intended)  // TODO: add tests
	choice at A {
		1() from A to B;  @'x<5'
		do Proto1(A, B);  @'<x-1>'
	} or {
		2() from A to B;  @'x>=5'
	}
}
//*/



/* // Testing new unsat
global protocol Proto1(role A, role B) {
	choice at A {
		1() from A to B;
	} or {
		2() from A to B;  @'False'
	}
}
//*/


/*  // Testing new unsat
global protocol Proto1(role A, role B) @'<x:=0>' {
	choice at A {
		1() from A to B;
		do Proto1(A, B);  @'<0>'  // Bad
		//do Proto1(A, B);  @'<1>'
	} or {
		2() from A to B;  @'x=1'
	}
}
//*/












/*
global protocol Proto1(role A, role B) @'<x:="123">' {
	//1() from A to B;
	1() from A to B; @'x = "123"'  // TODO: "internal" sort check?
}
//*/


/*
global protocol Proto1(role A, role B) @"<x:=122>" {
	1() from A to B; @"x < 123"  // CHECKME TODO: special case of "non-recursive" state vars? (no need to check assrt-prog with _x)
}
//*/


/*
global protocol OAuth (role C, role S, role A) {
 login(account: int) from S to C;
 do Auth(C, S, A); @"<0>"
}

//aux global protocol Auth (role C, role S, role A) @"<try:=0> try>=0 && try<=3" {
// password() from C to A;
// authed() from A to S;
//}

aux global protocol Auth (role C, role S, role A) //@"<try:=0> try>=0 && try<=3" {
                                                   @"<try:A=0> try>=0 && try<=3" {
 password(pwd: int) from C to A;
 choice at A {
   authed() from A to S;
   authed() from S to C;
 } or {
   again() from A to S; @"try<3"
   //again() from S to C;
   again() from S to C; //@"try<3"  // Cf. "global" statevars
   do Auth(C, S, A); @"<try+1>"
 } or {
   failure() from A to S; @"try=3"
   failure() from S to C;
 }
}
//*/


/*
global protocol Proto1(role A, role B) {
	//1(x: int) from A to B; @"x=123"
	1(x: String) from A to B; @"x='abc'"
	//2(y: int) from A to B; @"x=y"
	2(y: String) from A to B; @"x=y"
}
//*/

/* // FIXME: statevar syntax, sorts -- e.g., cf. AssrtCore.getInlined, statevars
global protocol Proto2(role A, role B) { //@"<y:='def'>"
	//1(x: String) from A to B; @"x='123 def'"
	1(x: String) from A to B; @'x="abc"'
	//1(x: int) from A to B; @"x=123"
}
//*/



/*
// A=3,  B=12345
global protocol Proto1(role A, role B) @"<x_A:=1> x_A>=0" {

	0(z:int) from A to B;	@"z=x_A"// && z=y_B"

	do Proto1Aux(A, B);  @"<z, z>"
}

//global protocol Proto1Aux(role A, role B) @"px_A>=0 && px_B>=0" { }

global protocol Proto1Aux(role A, role B) @"<x_A:=*, y_B:=*> x_A>=0 && y_B>=0" {

	choice at A
	{
		1() from A to B; @"x_A<5"
		3() from B to A; @"y_B<5"
		do Lock(A, B);  @"<x_A+1>"
	}
	or
	{
		2() from A to B; @"x_A>=5"
	}
}
//*/


/*
global protocol Lock(role A, role B, role C)
{
	REQ () from A to B;
	REQ () from A to C;
	choice at B
	{
		ACK () from B to A;
		//foo () from B to C;
		choice at C
		{
			ACK () from C to A;
			REL () from A to B;
			REL () from A to C;
		}
		or
		{
			do Lock(C, A, B);
			//REQ () from C to A;
			//REQ () from C to B;
		}
	}
	or
	{
		do Lock(B, A, C); // should we set the initial clocks here?
	}
}
//*/


/*
choice at A
{
	1() from A to B;
	3() from B to C;  // C?B:3
}
or
{
	2() from A to B;
	4() from B to C;  // C?B:4
}
//*/


/*
global protocol Lock(role A, role B, role C)
{
	REQ (tsrab:int) from A to B;
	REQ (tsrac:int) from A to C; @"tsrac > tsrab"
	choice at B
	{
		ACK (tsaba:int) from B to A; @"tsaba >  tsrab"
		choice at C -> B
		{
			ACK (tsaca:int) from C to A; @"tsaca > tsrac"
			REL (tsreab:int) from A to B; @"tsreab > tsrab"
			REL (tsreac:int) from A to C; @"tsreac > tsrac"
		}
		or
		{
			//....
			do Lock(C, A, B);
		}
	}
	or
	{
		do Lock(B, A, C); // should we set the initial clocks here?
	}
}
//*/


/*
global protocol Proto1(role A, role B)
		//@"<x:=3>"  // Bad
		@"<x:=3> x=3"
{
	1() from A to B; @"x=3"
	do Proto1(A, B); @"<3>"
	//do Proto1(A, B); @"<4>"  // Bad
}
//*/


/*
global protocol Proto1(role A, role B)
		//@"<x:=0> x>=0"
		@"<x:=0> x>0"  // Testing revised init-rec-assert check -- TODO: add test
{
	1() from A to B;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A to B;
	do Proto1Aux(A, B);  @"<123>"  // Testing f/w rec statevar expr endpoint graph building
			// An "encoding" of top-level statevar initialiser exprs
}

aux global protocol Proto1Aux(role A, role B)  @"<x:=0>"
{
	2() from B to A;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A to B;
	do Proto1Aux(A, B); @"<0>"  // Testing f/w rec statevar expr endpoint graph building
}

aux global protocol Proto1Aux(role A, role B) @"<x:=0>"
{
	choice at A
	{
		2() from A to B; @"x<5"
		do Proto1Aux(A, B); @"<x+1>"
	}
	or
	{
		3() from A to B; @"x>=5"
	}
}
//*/



/*
global protocol Proto1(role A, role B) @"<x:=0> x>=0"
{
	choice at A
	{
		1() from A to B; @"x<5"
		//do Proto1(A, B); @"<x+1>"
		//do Proto1(A, B); @"<x>"
		do Proto1(A, B); @"<x-1>"  // Bad -- TODO: add tests
	}
	or
	{
		2() from A to B; @"x>=5"
	}
}
//*/


/*
// testing "f/w rec" with a state assertion
global protocol Proto1(role A, role B)
{
	1() from A to B;
	do Proto1Aux(A, B); @"<0>"  // Testing f/w rec statevar expr endpoint graph building
}

aux global protocol Proto1Aux(role A, role B)
		//@"<x:=0> x>5"  // TODO: add tests
		@"<x:=0> x>=0"
{
	2() from B to A;
}
//*/


/*
global protocol Proto1(role A, role B) @"<x:=0>"
{
	choice at A
	{
		1() from A to B; @"x<5"
		do Proto1(A, B); @"<x+1>"
	}
	or
	{
		2() from A to B; @"x>=5"
				// Testing unsat after deprecating state var init exprs and "constant propagation"
				// Original intuition was to model "base case" and "induction step", but this is incompatible with unsat checking + loop counting
				//@"x=5"  // Bad assrt-prog
	}
}
//*/


/*
global protocol Proto1(role A, role B) @"<x:=0> x>1"
{
	1() from A to B;
	//do Proto1(A, B);  @"<x-1>"  // Bad -- CHECKME: add tests?
	//do Proto1(A, B);  @"<x>" // OK
	do Proto1(A, B);  @"<x+1>"
}
//*/


























/*
global protocol Proto1(role A, role B) //@<x:="0">  //"arithmetic/boolean expr"
{
	0(y:int) from A to B;
	do Proto1Aux(A, B);
}

aux global protocol Proto1Aux(role A, role B)
{
	choice at A
	{
		1() from A to B;  @"y<=0"
		do Proto1Aux(A, B);  //@<"x">
	}
	or
	{
		2() from A to B;  @"y>0"
	}
}
//*/



/* // CHECKME: pre vs. post assertions?  corresponds to static vs. dynamic?  cf. Eiffel
global protocol Proto1(role A, role B) @<x:="0">
{
	choice at A
	{
		1() from A to B; @"x<3"
		do Proto1(A, B); @<"x+1">
	}
	or
	{
		2() from A to B;	 @"x>=2"  // CHECKME: unsat -- solely due to constant prop?
	}
}
//*/


/*
global protocol Proto1(role A, role B) @<x:="0">
{
	choice at A
	{
		1() from A to B;
		do Proto1(A, B); @<"x+1">
	}
	or
	{
		2() from A to B;	 @"x>=5"  // CHECKME: unsat -- solely due to constant prop?
	}
}
//*/


/*
global protocol Proto1(role A, role B) @<x:="0">
{
	choice at A
	{
		1() from A to B;	@"x<5"
		do Proto1(A, B); @<"x+1">
	}
	or
	{
		2() from A to B;	 @"x>=5"  // CHECKME: unsat on first loop -- solely due to constant prop?
			 // this unsat is also "inconsistent" with the fact that having only x<=5 is also "potentially" unsat after some loops
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	(x: int) from A to B;  @"(!!True)"
	//2(y:int) from A to B; @"((y=2) && (y=(4+1)))"
	//(x: int) from A to B;  @"x = 1 + 3 - 4 *5"  // TODO add syntax tests (op precedence and assoc)
	//(y: int) from B to A;  @"y<0 || y > 1 && y>2"
}
//*/


/* // CHECKME -- [assrt-core] Cannot project
global protocol Proto1(role A, role B, role R)
{
	() from A to R;
	do Loop(A, B);
}

aux global protocol Loop(role A, role B)
{
	Res(b2:int) from A to B;
	choice at A
	{
		SecOut() from A to B;  @"b2>0"
	}
	or
	{
		SecIn() from A to B;   @"b2<=0"
		do Loop(A, B);
	}
}
//onto R: cannot merge unguarded rec vars
//*/






/* // good.extensions.assrtcore.safety.assrtprog.statevar.AssrtCoreTest37
global protocol Proto1(role A, role B) @<x:="1", y:="2"> "x>=1 && y>x"
{
	3(z1: int) from A to B;	 @"z1=x+y"
	do Proto1(A, B);         @<"y", "z1">
			// Testing `y` vs `y1` state arg -- differentiating V update between general renaming (x=_y) and "constant propagation" (x=2) special case
			// Cf. Fib -- also AssrtCoreTest08f/g
}
//*/


/* // AssrtCoreTest08f
global protocol Proto1(role A, role B) @<x:="3">
{
	1() from A to B; @"(x>2)"  // Testing ass in F, independent of pay
	do Proto2(A, B); @<"x">
}

// Not aux
global protocol Proto2(role A, role B) @<y:="4">
{
	1() from A to B; @"(y>2)"
	do Proto2(A, B); @<"y">
}
//*/











/* // good.extensions.assrtcore.safety.unsat.AssrtCoreTest35
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		Bes(b2:int) from B to A;
		choice at A
		{
			SecOut() from A to C;  @"b2>0"
			do Proto1(A, B, C);
		}
		or
		{
			SecIn() from A to C;   @"b2<=0"
			do Proto1(A, B, C);
		}
	}
}
//*/


/*  // TODO good.extensions.assrtcore.safety.unsat.AssrtCoreTest36
global protocol Proto1(role A, role B)
{
	Res(b2:int) from A to B;
	do Loop(A,B);
}

aux global protocol Loop(role A, role B)
{
	choice at A
	{
		SecOut() from A to B;  @"b2>0"
	}
	or
	{
		SecIn() from A to B;   @"b2<=0"  // TODO: "locked in" recursive choice, do by pruning unsat recursive choice cases?  Cf. unfair transform
				// CHECKME: b2>0 unsat after doing one b2<=0 (i.e., b2<=0&&b2>0 unsat)
				// drop unsat?  or somehow only do unsat for payload vars? (not state vars) -- or "weaken" unsat to not use V and implicitly forall statevars
				// or drop "constant propagation"?  or "init values"?
		do Loop(A, B);
	}
}
//*/



























/* Test035 -- Test037 */

/*
global protocol Proto1(role A, role B) @<x:="3">
{
	1() from A to B; @"(x>2)"  // Testing, V update also needs to GC F -- TODO add test
	do Proto1(A, B); @<"2">
}
//*/


/*
global protocol Proto1(role A, role B) @<x:="3">
{
	1() from A to B; @"(x>2)"  // Testing ass in F, independent of pay
	do Proto2(A, B); @<"x">
}

// Not aux
global protocol Proto2(role A, role B) @<y:="4">
{
	1() from A to B; @"(y>2)"
	//do Proto1(A, B); @<"y">
	do Proto2(A, B); @<"y">
}
//*/


/*// Testing (removal of) state args from messages, cf. duality between A and B (w.r.t. <1>)
global protocol Proto1(role A, role B, role C) @<x := "0">
{
	1() from A to B;
	2() from A to C;
	do Proto1(A, B, C); @<"1">  // TODO: add test
}
//*/














/*  // Fibs -- AssrtCoreTest4.scr
//global protocol Proto1(role A, role B) @<x:="0", y:="1"> "x>=0 && y>x"  // Bad (e.g., x=y=1)
global protocol Proto1(role A, role B) @<x:="0", y:="1"> "x>=0 && y>=x"
{
	1(x1: int) from A to B;	 @"x1=x"
	2(y1: int) from A to B;	 @"y1=y"
	3(z1: int) from B to A;	 @"z1=x1+y1"
	do Proto1(A, B);         @<"y", "z1">
}
//*/

/*
global protocol Proto1(role A, role B) @<x:="1", y:="2"> "x>=1 && y>x"
{
	1(x1: int) from A to B;	 @"x1=x"
	2(y1: int) from A to B;	 @"y1=y"
	3(z1: int) from B to A;	 @"z1=x1+y1"
	do Proto1(A, B);         @<"y", "z1">
}
//*/

/*
global protocol Proto1(role A, role B) @<x:="0", y:="1", z:="1"> "(x>=0 && y>=x) && z=x+y"  // FIXME: parentheses
{
	1(x1: int) from A to B;	 @"x1=x"
	2(y1: int) from A to B;	 @"y1=y"
	3(z1: int) from B to A;	 @"z1=z"
	do Proto1(A, B);         @<"y1", "z1", "y1+z1">
}
//*/

/*
global protocol Proto1(role A, role B) @<x:="0", y:="1"> "x>=0 && y>=x"
{
	choice at A
	{
		1(x1: int) from A to B;	 @"x1=x"
		2(y1: int) from A to B;	 @"y1=y"
		3(z1: int) from B to A;	 @"z1=x1+y1"
		do Proto1(A, B);         @<"y", "z1">
	}
	or
	{
		4() from A to B;
	}
}
//*/













/* Test032 -- Test034 */

/* // Testing rec assertion
global protocol Proto1(role A, role B) @<x:="0"> "x>=0"
{
	1(y: int) from A to B; @"y>0"  // Comment annotation is bad
	do Proto1(A, B); @<"y">
}
//*/


/* // Testing rec assertion
global protocol Proto1(role A, role B) @<x:="0"> "x>=0"
{
	1(y: int) from A to B; @"y>x"  // Comment annotation is bad
	do Proto1(A, B); @<"y">
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	1(x: int) from A to B;  @"x>=0"
	2(y: int) from B to C;  @"y=x && y>=0"  // Knowledge about x/y "told" to C
	//2(y: int) from B to C;  @"y=x"  // (Intended) bad if replace above line -- fails assert-prog for C, C doesn't know x>=0
	3(z: int) from C to A;  @"z=y && z>=0"
}
//*/





/* // good.extensions.assrtcore.safety.unsat.AssrtCoreTest23
global protocol Proto1(role B, role A) @<x:="0">  // @<x:"x=0"> "x<10"
{
	//1(x: int) from A to B;  @"x > 1"
	5(Offer:int) from B to A;	 // Checking F updated properly (old Offer in F renamed)
	choice at A
	{
		hag() from A to B; @"(Offer>x)"  // Unsat check -- no explicit assert-prog check (to z3 -- squashed)
		do Proto1(B, A);   @<"Offer">
		//do Proto1(A, B);   @<"Offer">  // TODO CHECKME: Offer in scopes at B, "duplicate" annot  -- current -assrt (should) forbids role-arg premut.?
	}
	or
	{
		sell() from A to B;
	}
}
//*/











/* // CHECKME: val forwarding, w.r.t. local K+F's
global protocol Proto1(role A, role B)  @<x := "1"> "x > 0"
{
	choice at A
	{
		1(y: int) from A to B;  @"y > 1"
		do Proto1(A, B);  @<"y">
	}
	or
	{
		2() from A to B;  // Testing rec-assrt check, input branch checks action based on enqueue message
	}
}
//*/


/*
// CHECKME: val forwarding, w.r.t. local K+F's
global protocol Proto1(role A, role B, role C)
{
	1(x: int) from A to B;  @"x > 1"
	1(y: int) from B to C;  @"x = y"
}
//*/
















/*
global protocol Proto1(role A, role B, role C)
{
	1(x: int) from A to B;
	2(y: int) from A to C;
	do Proto1(A, B, C);  // Testing updateScopes, records *past* scopes (i.e., excluding current) in order
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	0() from A to B;
	do Loop(A, B, C);
}

aux global protocol Loop(role A, role B, role C)
{
	IsAbove(v1:int) from A to B;
	SecOut(r2:int) from A to C;
			// Testing updateScopes model construction -- v1 can be dropped and re-sent before first r2 is picked (async recursion) -- increases state space
			// Tests updateScopes, non-initial self-recursion
	do Loop(A, B, C);
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	Plane(x1:int, x2:int, x3:int, x4:int) from A to B;
	do Loop(A, B, C);
}

aux global protocol Loop(role P, role R, role C)
{
	choice at P
	{
		IsAbove(v1:int) from P to R;
		Res(b1:int) from R to P;
		IsAbove(v2:int) from P to R;
		Res(b2:int) from R to P;
		choice at P
		{
			BothIn() from P to R;
			BothIn(r1:int) from P to C;
			do Loop(P, R, C);
		}
		or
		{
			BothOut() from P to R;
			BothOut() from P to C;
			do Loop(P, R, C);
		}
		or
		{
			Intersct(y1:int, y2:int) from P to R;
			Res(i:int) from R to P;
			choice at P
			{
				SecOut(r2:int) from P to C;  // Testing tarjan -- updateScopes explodes state space, three-party-interleaves async recursion with K/F-GC
				do Loop(P, R, C);
			}
			or
			{
				SecIn(r3:int, r4:int) from P to C;
				do Loop(P, R, C);
			}
		}
	}
	or
	{
		Close() from P to R;
		Close() from P to C;
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x: int) from A to B;  @"x>0"  // Testing updateScopes
	2(y: int) from A to B;  @"y>x"
	do Proto1(A, B);
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x: int) from A to B;  @"x>0"  // Testing updateScopes (always empty scopes)
	do Proto1(A, B);
}
//*/


















/* Test019 -- Test31, though a few bad tests omitted */

/*
global protocol Proto1(role A, role B) @"x>0"  // test unknown x -- also tested empty lhs for getRecAssertCheck
{
	1() from A to B;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A to B;
	//do Proto1Aux(A, B);  // TODO: do-sexpr WF -- CHECKME: or allow? (cf., below)
	do Proto1Aux(A, B);  @<"1">
}

aux global protocol Proto1Aux(role A, role B)  @<x := "1"> "x>0"  // Testing getRecAssertCheck lhs building
{
	2() from B to A;
}
//*/


/*
global protocol Proto1(role A, role B) @<x := "1">
{
	1() from A to B;
	do Proto1(A, B);  @<"2">  // Testing svar initial and update values
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A to B;
	do Proto1Aux(A, B);  @<"2">  // Testing "inlining" of do-sexpr args as rec-svar exprs by proto inlining
}

aux global protocol Proto1Aux(role A, role B)  @<x := "1"> "x>0"
{
	2() from B to A;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A to B;
	do Proto1Aux(A, B);  @<"2">  // testing, no target satate var
}

aux global protocol Proto1Aux(role A, role B)  //@"x>0"
{
	2() from B to A;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A to B;
	do Proto1Aux(A, B);  // TODO CHECKME: allow? (omitted state args)
}

aux global protocol Proto1Aux(role A, role B)  @<x := "1">
{
	2() from B to A;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(y:int) from A to B;  @"y>1"  // TODO: testing F var renaming/compacting -- A async returns to rec-state while B still in "prev" iteration
	do Proto1(A, B);
}
//*/


/*
global protocol Proto1(role A, role B) @<x := "1">
{
	1(y:int) from A to B;  @"y>1"
	do Proto1(A, B);  @<"y">  // TODO: testing F var renaming/compacting and V/R renaming
}
//*/


/*
global protocol Proto1(role A, role B) @<x := "1">
{
	1() from A to B;
	2() from B to A;
	do Proto1(A, B);  @<"2">
}
//*/


/*
global protocol Proto1(role A, role B) @<x := "1">
{
	1() from A to B;  // Testing removal of _dum1 : _Unit translation for empty payload -- reduces model size
	do Proto1(A, B);  @<"2">
}
//*/


/*
global protocol Proto1(role A, role B) @<x := "1">
{
	1() from A to B;  // Testing removal of _dum1 : _Unit translation for empty payload -- reduces model size
	do Proto1(A, B);  @<"1">  // Testing .toTrueAssertion state exprs
}
//*/


/*
global protocol Proto1(role A, role B) @<x := "1">
{
	// FIXME: unused role decls

	do Proto1(A, B);  @<"1">  // (But tested .toTrueAssertion state exprs)
}
//*/


/*
global protocol Proto1(role A, role B) @<x := "1">
{
	1() from A to B;
	do Proto1(A, B);  // CHECKME: OK?
}
//*/





















/* Test001 -- Test018 */

/*
global protocol Proto1(role A, role B)
{
	1() from A to B;  @"True"
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x: AssrtCoreTest.int) from A to B;  @"True"
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x: int) from A to B;  @"True"
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x: int) from A to B;  @"x>0"
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x: int) from A to B;  @"x > 0"  // Testing whitespace
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A to B;  @"x > 0"  // Testing unknown var error
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x: int) from A to B;  @"x > 0"
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A to B;  @"False"  // Testing assrt-prog
}
//*/


/*
global protocol Proto1(role A, role B)
{
	choice at A
	{
		1() from A to B;  @"False"  // Testing assrt-unsat
	}
	or
	{
		2() from A to B;  @"True"
	}
}
//*/


/*
global protocol Proto1(role A, role B)  @"True"
{
	1() from A to B;
}
//*/


/*
global protocol Proto1(role A, role B)  @<x := "1"> "True"
{
	1() from A to B;
}
//*/


/*
global protocol Proto1(role A, role B)  @<x := "1">
{
	1() from A to B;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A to B;
	do Proto1(A, B);  // Testing base recursive do, inlining
}
//*/


/*
global protocol Proto1(role A, role B)
{
	do Proto1Aux(A, B);  // Testing base f/w entry do, inlining
}

aux global protocol Proto1Aux(role A, role B)
{
	1() from A to B;
	do Proto1Aux(A, B);
}
//*/


/*
global protocol Proto1(role A, role B)
{
	do Proto1Aux(A, B);  // Testing base f/w entry do with recursive do, inlining
}

aux global protocol Proto1Aux(role A, role B)
{
	1() from A to B;
	do Proto1Aux(A, B);
}
//*/


/*
global protocol Proto1(role A, role B)
{
	do Proto1Aux(A, B);  @<"0">  // TODO CHECKME: OK to f/w entry "override" default sexprs?  (depends if default sexprs are for "init" only or not)
}

aux global protocol Proto1Aux(role A, role B)  @<x := "1">
{
	1() from A to B;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	do Proto1Aux(A, B);  // TODO? conversely, OK to not supply sexprs?  (o/w rec statevar decl exprs only for root?)
}

aux global protocol Proto1Aux(role A, role B)  @<x := "1">
{
	1() from A to B;
}
//*/


/*
global protocol Proto1(role A, role B)  @<x := "0">
{
	do Proto1(A, B);  @<"1">  // FIXME: A, B, not used
}
//*/


/*
global protocol Proto1(role A, role B)  @<x := "0">
{
	1() from A to B;
	do Proto1(A, B);  @<"1">
}
//*/



















/* // AssrtCoreTest4.scr
global protocol Proto1(role C, role S)
{
	HELLO(u:int) from C to S;
	choice at C
	{
		ADD(w:int) from C to S;
		ADD(v:int) from C to S;
		RES(f:int) from S to C;
		do Proto1(C, S);
	}
	or
	{
		BYE() from C to S;
		BYE() from S to C;
	}
}
//*/


/*
global protocol Proto1(role C, role S)
{
	HELLO(u:int) from C to S;
	choice at C
	{
		ADD(w:int) from C to S;  @"w > 0"
		ADD(v:int) from C to S;  @"v > 0"
		RES(f:int) from S to C;  @"f > 0"
		do Proto1(C, S);
	}
	or
	{
		BYE() from C to S;
		BYE() from S to C;
	}
}
//*/


/*
global protocol Proto1(role P, role R, role C)
{
	Plane(int, int, int, int) from P to R;  // Currently same state space as below, due to "_dum" var names (and K/scopes)
	do Loop(P, R, C);
}

aux global protocol Loop(role P, role R, role C)
{
	choice at P
	{
		IsAbove(int) from P to R;
		Res(int) from R to P;
		IsAbove(int) from P to R;
		Res(int) from R to P;
		choice at P
		{
			BothIn() from P to R;
			BothIn(int) from P to C;
			do Loop(P, R, C);
		}
		or
		{
			BothOut() from P to R;
			BothOut() from P to C;
			do Loop(P, R, C);
		}
		or
		{
			Intersct(int, int) from P to R;
			Res(int) from R to P;
			choice at P
			{
				SecOut(int) from P to C;
				do Loop(P, R, C);
			}
			or
			{
				SecIn(int, int) from P to C;
				do Loop(P, R, C);
			}
		}
	}
	or
	{
		Close() from P to R;
		Close() from P to C;
	}
}
//*/


/*
global protocol Proto1(role P, role R, role C)
{
	Plane(x1:int, x2:int, x3:int, x4:int) from P to R;
	do Loop(P, R, C);
}

aux global protocol Loop(role P, role R, role C)
{
	choice at P
	{
		IsAbove(v1:int) from P to R;
		Res(b1:int) from R to P;
		IsAbove(v2:int) from P to R;
		Res(b2:int) from R to P;
		choice at P
		{
			BothIn() from P to R;
			BothIn(r1:int) from P to C;
			do Loop(P, R, C);
		}
		or
		{
			BothOut() from P to R;
			BothOut() from P to C;
			do Loop(P, R, C);
		}
		or
		{
			Intersct(y1:int, y2:int) from P to R;  // unfoldScopes state space increase (async recursion with scopes resetting)
			Res(i:int) from R to P;
			choice at P
			{
				SecOut(r2:int) from P to C;
				do Loop(P, R, C);
			}
			or
			{
				SecIn(r3:int, r4:int) from P to C;
				do Loop(P, R, C);
			}
		}
	}
	or
	{
		Close() from P to R;
		Close() from P to C;
	}
}
//*/


/*
global protocol Proto1(role P, role R, role C)
{
	Plane(x1:int, x2:int, x3:int, x4:int) from P to R;
	do Loop(P, R, C);
}

aux global protocol Loop(role P, role R, role C)
{
	choice at P
	{
		IsAbove(v1:int) from P to R;
		Res(b1:int) from R to P;  @"b1=0 || b1=1"
		IsAbove(v2:int) from P to R;
		Res(b2:int) from R to P;  @"b2=0 || b2=1"
		choice at P
		{
			BothIn() from P to R;  @"b1=1 && b2=1"
			BothIn(r1:int) from P to C;
			do Loop(P, R, C);
		}
		or
		{
			BothOut() from P to R;  @"b1=0 && b2=0"
			BothOut() from P to C;
			do Loop(P, R, C);
		}
		or
		{
			Intersct(y1:int, y2:int) from P to R;  @"(b1=1 && b2=0) || (b1=0 && b2=1)" // && y1=v1 && y2=v2
			Res(i:int) from R to P;
			choice at P
			{
				SecOut(r2:int) from P to C;  @"b2=0" // && r2=i
				do Loop(P, R, C);
			}
			or
			{
				SecIn(r3:int, r4:int) from P to C;  @"b2=1" //  && (r3=i && r4=v2)
				do Loop(P, R, C);
			}
		}
	}
	or
	{
		Close() from P to R;
		Close() from P to C;
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	NumberOne (x: int) from A to B;  //@"x > 3"
	NumberTwo (y: int) from B to C; @ "x = y"
	ReturnValueTwo (z: int) from C to B; @ "z = y + y"
	ReturnValueOne (t: int) from B to A; @ "t = z"
			// Testing what does A know about t -- A knows t=z, but not z = y+y   // CHECKME: OK for A to know "t" (K+F)?  should be sound
			// In general y could be from anywhere, and A won't know y's value
			// However, in this case y = x and x came from A -- CHECKME: refine?  or perhaps if z = x + x
}
//*/


/*  Cf. Fib.scr
global protocol Proto1(role C, role S)  @<x := "0", y := "1"> "y>0 && x>=0"
		//@"(x := 0, y := 1) y>0 && x>0"  // Bad initial Rass (and later unsat)
		//@"(x := 0, y := 1) (y>0))"
{
	choice at C
	{
		Val(x1:int) from C to S;  @"x1 = x"
		Add(y1:int) from C to S;  @"y1 = y"
		Sum(z:int) from S to C;   @"z = (x1+y1)"
		do Proto1(C, S);          @<"y1", "z">  // CHECKME
	}
	or
	{
		Bye() from C to S;
	}
}
//*/















































/*
global protocol Proto1(role A, role B)
{
	//1(x:int) from A to B;  @"x>1 || (x>2 && x>3)"  // Testing CNF

	//1(x:int) from A to B;  @"(x>1 && x>2) || x>3"
}
//*/

/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;
	//2(y:int) from A to B;  @"y=x+x && x=x"  // TODO: combine multiple exprs into sigma conjunction
	2(y:int) from A to B;  @"y=x+x"
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	1(x:int) from A to B;  @"x>3"
	choice at A
	{
		2(int) from A to B;  @"x>5"

		//3(int) from A to C;  @"x>6"  // Bad  // TODO add as unit test
		3(int) from A to C;  @"x>4"  // OK
	}
	or
	{
		4(int) from A to B;
		5(int) from A to C;
	}
}
//*/



/*
global protocol P1(role A, role B, role C)
{
	1(x:int) from A to C;
	2(y:int) from B to C;  @"y>x"

	//2(y:int) from C to B;  @"y>x"  // CHECKME: paper definition
}

global protocol P2(role A, role B)
{
	1(x:int) from A to B;  @"x>3"
	choice at B
	{
		2() from B to A;
	}
	or
	{
		3(y:int) from B to A; @"((y > (x + 1)) && y < 4)"
	}
}

global protocol P3(role A, role B, role C)
{
	1(x : int) from A to B; @"x > 3"
	2(y : int) from C to B; //@"(y<3 || y=3)"//"!(y=3)"//@"True"
	choice at B
	{
		3() from B to A; @"x < y"
	}
	or
	{
		4() from B to A; @"x > y"
	}
}
//*/



/*
global protocol Proto1(role A, role B, role C)
{
	/*1(x : int) from A to B; @"x > 3"
	choice at B
	{
		2() from B to A; @"True"
	}
	or
	{
		3(y : int) from B to A; @"((y > (x + 1)) && y < 4)"
	}*/

	/*1(x : int) from A to B; @"x > 3"
	2(y : int) from C to B; @"True"
	choice at B
	{
		3() from B to A; @"x < y"
	}
	or
	{
		4() from B to A; @"y > x"
	}* /

	1(x:int) from A to B;  @"x>3"
	2(y:int) from A to C;  @"y>x"




	/*0(z:int) from B to A;   @"(z>3)"
	choice at A
	{
		1(x:int) from A to B;   @"(x>3)"
	}
	or
	{
		2(y:int) from A to B;   @"(y>3)"
	}*/




	/*choice at B
	{
		2(y:int) from B to A;   @"y=x && y>3"
	}
	or
	{
		3(z:int) from B to A;   @"z=x && z<3"
	}* /
}
//*/


/*
assert f(x:int) bool = "x";
		// Cannot be recursive as an assertion -- so not so useful for "explicit" code gen?  (vs. basic expr capturing) -- mainly use as "assertion code gen"?
		// Should only be for validation?

global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;
	//2(y:int) from B to A;  @"y = f(x)"
	2(y:int) from B to A;
}
*/


/*
global protocol Proto1(role A, role B, role C) {
	choice at A
	{
		1() from A to B; @"A1"
		1() from A to C;           // CHECKME: receiver-side ass not projected -- but if it were, would need A1
	}
	or
	{
		...
	}
}
//*/


/*
global protocol SH(role P, role R, role C) {
	plane(x1:int, x2:int, x3:int, x4:int) from P to R;
	do Loop(P, R, C);
}

global protocol Loop(role P, role R, role C) {
	choice at P {
		Above(v1:int) from P to R;
		Res(b1:int) from R to P;  @"b1=0 || b1=1"
		Above(v2:int) from P to R;
		Res(b2:int) from R to P;  @"b2=0 || b2=1"
		choice at P {
				BothIn() from P to R;  @"b1=1 && b2=1"
				BothIn(r1:int) from P to C;
				do Loop(P, R, C);  // Recursion
			} or {
				BothOut() from P to R;  @"b1=0 && b2=0"
				BothOut() from P to C;
				do Loop(P, R, C);  // Recursion
		} or {
			Intersect() from P to R;  @"(b1=1 && b2=0) || (b1=0 && b2=1)"
			Res(i:int) from R to P;
			choice at P {
				One(r2:int) from P to C;   @"b2=0 && r2=i"
				do Loop(P, R, C);  // Recursion
			} or {
				Two(r3:int, r4:int) from P to C;  @"b2=1 && (r3=i && r4=v2)"
				do Loop(P, R, C);  // Recursion
		} }
	} or {
		Close() from P to R;
		Close() from P to C;  // End
	}
}
//*/


/*
global protocol SH(role P, role R, role C) {
	plane(x1:int, x2:int, x3:int, x4:int) from P to R;
	rec Loop {
		choice at P {
			check(p1:int, p2:int) from P to R;
			PointsToForward(res:int) from R to P; @"res>=0 && res<=2"
			choice at R {
				noIntersection() from R to P; @"res=1"
				OnePoint(v1:int) from P to C; @"v1=p2"
				continue Loop;
			} or {
				noPoints() from R to P; @"res=0"
				noPoints() from P to C;
				continue Loop;
			} or {
				intersection(p3:int) from R to P; @"res=1 || res=2"
				choice at P {
					OnePointb(v2:int) from P to C; @"res=1 && v2=p3"
					continue Loop;
				} or {
					TwoPoint(v3:int, v4:int) from P to C; @"res=2 && (v3=p3 && v4=p2)"
					continue Loop;
				}
			}
		} or {
			Close() from P to R;
			Close() from P to C;
		}
	}
}
//*/



/*
global protocol Proto1(role A, role B)
{
	//1(x:int, y:int) from A to B;  @"x>3 && y>4"  // OK

	/*1(x:int, y:int) from A to B;  @"x=y"  // OK
	2() from B to A;  @"x=y"* /

	1(x:int, y:int) from A to B;
	2() from B to A;  @"x=y"  // Bad
}
//*/












/*
..demo:
- model building: model state extensions for assertions
-- assert-prog vs. sat -- DbC assert-prog choice case disjunction
-- bounded model with recursion (1): actvar renaming ("oldvar" GC) -- leveraging syntactic unfolding "semantics" of recursion
-- async MP: renaming following message flows
- statevars
-- bounded model with recursion (2): conservative forall on old statevars
-- "same var" special case
-- statevar invariants -- statevar-assert-prog
- uninterpreted funs
-- domain-specific theories (e.g., open/port)
-- encode roles/etc as ints
-- domain-specific API gen

global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;  @"x>3"

	choice at B
	{
		2() from B to A;  @"x<0"
		4() from B to A;  @"False"
	}
	or
	{
		3() from B to A;  @"True"
	}
}
//*/


























/*
global protocol Proto1a(role A, role B)  @"(x:=1)"
{
	1(x:int) from A to B;
	2(y:int) from B to A;	 @"y>x"

	do Proto1a(A, B);  @"<x+1>"
}

global protocol Proto1b(role A, role B)
{
	1() from A to B;
	2(y:int) from B to A;	 @"y>x"
}

global protocol Proto1c(role A, role B)
{
	1() from A to B;	     @"x>3"
	2(y:int) from B to A;	 @"y>x"
}

global protocol Proto1d(role A, role B, role C)
{
	1(x:int) from A to B;	 @"x>3"
	2(y:int) from B to C;	 @"y>x"  // y>x added to F(C), but x *not* added to F(C) -- N.B. x will be forall quantified at C, and x>3 *not* in F(C)
	3(z:int) from C to A;	 @"z>x"
}

global protocol Proto1e(role A, role B, role C)
{
	1(x:int) from A to B;	 @"x>3"
	2(y:int) from B to C;	 @"y>x"
	3(z:int) from A to C;	 @"z>x"  // assertion not checked on receiver side
}

global protocol Proto1f(role A, role B, role C, role D)
{
	1(x1:int) from A to B;	@"x1=3"
	2(x2:int) from A to D;	@"x2=x1"

	3(y1:int) from B to C;	@"y1=x1"
	4(y2:int) from D to C;	@"y2=x2"

	5(z:int) from C to A;   @"z=y1 && z=y2"  // only adding "immediate" assertion to F is weak? can strengthen?
}
//*/












/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;  @"!(x<3)"
	2() from A to B;  @"(True && !(False))"

}
//*/

/*
global protocol Proto1(role A, role B)
{
	1() from A to B;
	do Proto2(A, B);
}

aux global protocol Proto2(role A, role B) @"2<3"  // testing, unknown vars check
{
	2() from A to B;
}
//*/

/*
global protocol Proto1(role A, role B) @"(x:=(1+(1-1)), y:=4)"
{
	1() from A to B; @ "(x<3 && x<3) || x<3+(1+2)"
	//@"(((x>1) && (x>2)) && (x>3))"
	//@"(((True)))"
	2() from B to A; @"foo()"  // CHECKME: constants
	//2() from B to A; @"((((True))))"
	do Proto1(A, B);  @"<0, 0>"
}
//*/



// TODO try: mu X . ( A->B 1 . X + A->B 2 . mu Y . A->B 3 . Y ) with statevars and assertions

/*
global protocol Proto1(role A, role B)
		@"(x := 1) (x>0)"
		//@"(x := 0) (x>0)"
{
	//1(y:int) from A to B; @"(y>1)"
	1() from A to B;
}
//*/

/*
global protocol Proto1(role A, role B)
{
	//1(y:int) from A to B; @"(y>1)"
	1(y:int) from A to B; @"(y>3)"
	do Proto2(A, B); @"(y)"
}

aux global protocol Proto2(role A, role B) @"(x := 0) (x>2)"
{
	2() from B to A;
}
//*/

/*
global protocol Proto1(role A, role B)  @"(x := 1)"
{
	1(y:int) from A to B;  @"(y > x)"
	2() from B to A;
	do Proto1(A, B);  @"(x)"
}
//*/

/*
global protocol Proto1(role A, role B)
		@"(x := 3) (x>2)"
		//@"(x := 3) (x>0)"
		//@"(x := 3) (x>1)"
{
	1() from A to B; @"(x>1)"
	//2() from B to A;
	//do Proto1(A, B);  @"(x)"
			// CHECKME: no longer needs to be special case, given appropriate rec-assertion? -- but at least is an optimisation?
			// no: special case still different, no "old var" renaming (no "inductive unrolling")
	//do Proto1(A, B);  @"((x+1))"
	do Proto1(A, B);  @"((x-1))"
}
//*/

/*
//global protocol Proto1(role A, role B)  @"(x := 1)"
global protocol Proto1(role A, role B)  @"(x := 2) (x>1)"
//global protocol Proto1(role A, role B)  @"(x := 1) (y>0)"
{
	//1() from A to B;
	//1() from A to B; @"(x>0)"
	1() from A to B; @"(x>1)"
	2() from B to A;

	//do Proto1(A, B);  @"(x)"
	//do Proto1(A, B);  @"((x+1))"
	do Proto1(A, B);  @"((x-1))"
}
//*/

















// uninterpreted functions for custom API gen
// multi statvars -- fibo, linear
/*
global protocol Proto1(role A, role B) @"(x:=(0+3), y:=1)"
{
	1(z:int) from A to B;  @"(x>1)"
	do Proto1(A, B); @"(3, 1)"
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	1(lin x:int) from A to B; @port(x, C);  // implies port(x, C) and not(port(x, A)), not(port(x, B))

	rec X1 (used_x = 0) {

		1(z:int) from B to C; @(fw(x -> z) ... used_x =0); // implies port(x, C) and not(port(x, A)), not(port(x, B))

		rec X2 (used_x = 1) {

			1(z2:int) from B to C; @(... used_x = 0); // implies port(x, C) and not(port(x, A)), not(port(x, B))

			connect B to C;
			2(y:int) from B to A; @(x=y);

			connect C to A; @request(x, C);  // C should know x; should imply port(x, C);
		}
		}
} // terminal state needs all linear used
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;
	2(y:int) from B to A; @(x=y);
	3(z:int) from B to A; @(z=y);  // Should this be "linearity" error?
}
//*/


























/*/
global protocol Proto1(role A, role B) @(x=0);
{
	1() from A to B;
	do Proto2(A, B);
}

aux global protocol Proto2(role A, role B)
{
	2() from B to A; @(x<1);  // CHECKME: shouldn't be in scope without decl as Proto2 statevar -- OK because aux? error caught if Proto2 checked as root
}
//*/

/*
global protocol Proto1(role B, role S)
{
	ok() from B to S;
	do Proto2(B, S); @Quote;  // testing, unknown vars check
}

global protocol Proto2(role B, role S) @(x=0);
{
	5() from B to S;	@False;//@(y>0);  // testing, unknown vars check here too?
}
//*/


/*
global protocol Proto1(role A, role B) @(z=3);
{
	1(x:int) from A to B; @(x=3);
	2(y:int) from A to B; @(y>x);
	do Proto1(A, B);  // testing, statevar arg check
}
//*/












/*
global protocol Proto1(role A, role B) @(x=3);
{
	1() from A to B; @(x>2);
	do Proto2(A, B); @(x);
			// CHECKME: need to make expr vars "old" in F? -- proto shouldn't be valid?
			// could rename target y to x in this case? relies on "globally" (across subprotos) unique vars -- cf. rolename substitution
}

// Not aux
global protocol Proto2(role A, role B) @(y=4);
{
	1() from A to B; @(y>2);
	do Proto1(A, B); @(y);
}
//*/

/*
global protocol Proto1(role A, role B)
{
	do Proto2(A, B); @1;
			// CHECKME: in this case, consider substituting the x in Proto1<x+1> like DbC? but would be inconsistent generally?
			// CHECKME: at least consider case for substituting x if syntactically just "x" and still just x -- cf. bad.extensions.assrtcore.safety.assrtprog.statevar.AssrtCoreTest08b
}

global protocol Proto2(role A, role B) @(x=1);
{
	1(y:int) from A to B; @((y=x) && (x=1));

	//do Proto1(A, B); @1;
	do Proto2(A, B); @(x+1);
			// Unsat -- cf. DbC? -- OK there? but relies on two-unfolding cut off?
			// No: DbC subs the x in X<x+1> fixing it to two at two unfoldings and forever after? that's why safe there

	// TODO: check tests for "loop counting", e.g., X<x+1> -- and also with lower bounded ints (do bounds manually)
}
//*/

/*
global protocol Proto1(role A, role B) @(x=3);
{
	1() from A to B; @(x>2);

	//do Proto1(A, B); @x;  // Currently unsat -- cf. DbC? -- DbC it wouldn't be "x", it would "already" be 3 from substitution
			// Note, Proto1 could be called from "any context", so x can really be anything
			// CHECKME: make sat? treat single var formula as special case? cf. equality in "non-local" assertions vs. gt/lt

	//do Proto1(A, B); @(x+1);  // Unsat
	do Proto1(A, B); @(x-1);  // Unsat -- should be unsat
}
//*/

/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;
	do Proto2(A, B);
}

aux global protocol Proto2(role A, role B)
{
	2(x:int) from B to A;  // CHECKME: need proper var shadowing
}
//*/
















// ---


/*
global protocol Proto1(role A, role B, role C)
{
	1(x:int) from A to B; @(x>3);
	2(y:int) from B to C; @(y>x);  // OK: B knows x

	//---

	1(x:int) from A to B; @(x>3);
	2() from B to C;
	3(y:int) from C to B; @(y>x);  // Bad: C doesn't know x -- though it knows x > 3 -- CHECKME: how to disallow this? but still allow the below
			// CHECKME: DbC -- cf. HS

	//---

	1(x:int) from A to B; @(x=3);  // CHECKME: but equality should be strong enough?
	2() from B to C;
	3(y:int) from C to B; @(y>x);
}
//*/


/*
global protocol Proto1(role A, role B) @(z=0);
{
	1(x:int) from A to B; @(x>3);
	2(y:int) from B to C; @(y>x);  // C does *not* "know" x -- but knows constraints must be satisfied up to here
	3(z:int) from C to D; @(z>y);

//--- vs.

	1(x:int) from A to B; @(x=3);  // equality is "precise" enough for "strong path inference"
	2(y:int) from B to C; @(y>x);
	3(z:int) from C to D; @(z>y);
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	1(x:int) from A to B; @(x>1);
	2(y:int) from B to C; @(y>x);

	//3(z:int) from C to A; @(z=y);  // OK
	3(z:int) from C to A; @((z=y)&&(y>x));  //  Morally same as above -- given C should know this from the "path" here
			// CHECKME? C doesn't know x -- but could pass prev assertions along with current? cf. DbC projection (at receiver)
			// DbC projection vs. HS/TS? -- DbC receive-exists projection vs HS/TS "forall"?
}
//*/



















/*
global protocol Proto1(role A, role B, role C)
{
	// testing "passing" rename (shadow) map with messages -- also need to test re-receiving rename map with already applied renaming

	1(x:int) from A to B; @(x>3);
	2(y:int) from B to C; @(y>x);  // compacting doesn't terminate -- CHECKME: F renaming needs to be done based on K? i.e., also rename x in F(C)?
	//3(z:int) from C to D; @(z>x);  // ... CHECKME: but what if C uses x again in upcoming assertions after the renaming? -- hence pass the renaming as a message
			// -- keep a ("one-level"?) rename map? -- cf. rec unfolding with rec-annotation substitution
			// -- no: C can't use x as a sender, not known; but how about as receiver?
			// -- should renamed vars be recorded in K?
	//3(z:int) from B to C; @(z>x);
	do Proto1(A, B, C);
}
//*/




























































// --- ???


/*
global protocol JavaSmtBug(role B, role S) @(x=0);
{
	5() from B to S;	@False;//@(y>0);
	do JavaSmtBug(B, S); @x;  // Cf. AssrtExistsFormula::toJavaSmtFormula comments
}
//*/


/*
global protocol Proto1(role A, role B) @(x=3);
{
	choice at A
	{
		1(int) from A to B;
		do Proto1(A, B); @4;
	}
	or
	{
		2(int) from A to B;
		do Proto1(A, B); @3;
	}

		//1(y:int) from A to B; @(x=4);

		//1(y:int) from A to B; @((y=4) && (x=y));

		//1(y:int) from A to B; @(x=y);


		//do Proto1(A, B); @3;
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1(int) from A to B;
		4(int) from A to C;
	}
	or
	{
		2(int) from A to B;
		3(int) from A to C;
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	choice at A
	{
		1(x:int) from A to B;
		choice at A
		{
			2(y:int) from A to B;
			do Proto1(A, B);
		}
		or
		{
			3(z:int) from A to B;
		}

	}
	or
	{
		2(int) from A to B;
	}
}
//*/

