//Raymond@HZHL3 ~/code/eclipse/scribble/github.com/rumineykova/scribble-java
//$ bin/scribblec-assrt.sh -ip scribble-assertions/src/test/scrib/ -d scribble-assertions/src/test/scrib/ scribble-assertions/src/test/scrib/assrt/tmp/AssrtTest.scr 


// http://sandbox.kidstrythisathome.com/erdos/


module assrt.tmp.AssrtTest;


type <dotnet> "System.UInt32" from "..." as int;
type <dotnet> "System.String" from "..." as str;


// FIXME: debug printing for assertion passes


// - assertion validation
// - receive assertions -- why receive assertions?  should WF imply receive assertions always true?
// - explicit connections

//	.. rename connect to request
//	.. refactor a GConnectionAction (cf. LConnectionAction)

// .. need to update SubprotocolSig and "cycle" detection for protocoldecl/do annots? -- protocol inlining/unfolding with annots/assertions
// .. how about "syntactic" reachability check with protocoldecl/do annots?

// - recursion annotations
// - port forwarding annotations/assertions
// - arrays? -- cf. dependent types for array/list lengths -- https://www.reddit.com/r/fsharp/comments/28bbsr/faking_dependent_types_in_f/

// redo inlining/unfolding via model building? role/param/assert all in model states?


global protocol Proto1(role A, role B)
{
	1(x:int) from A to B; @(x=1);
}


/*
global protocol Proto1(role B, role S) @(x=3);
{
	1(y:int) from B to S; @(y>3);
	choice at S
	{
		//2(z:int) from S to B; @((z>y) &&(y>3));

		2() from S to B; @(y>x);
		do Proto1(B, S); @y;
	}
	or
	{
		4() from S to B;
	}
}
/*/


/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B; @(x=1);	
	2(y:int) from A to B; @((y=2) && (y=(x+1)));	
	3(z:int) from A to B; @((z=3) && (z=(y+1)));	
}
//*/


/*
global protocol Proto1(role A, role B) @(x=3);
{
	1() from A to B; @(x>2);	
	do Proto1(A, B); @(x+1);
}
//*/


/*
global protocol Proto1(//role A,
		role B, role C)
{
	//RES(y:int) from A to B;
	RES(z3:int) from B to C; 
	RES(z4:int) from B to C; @(z4 = z3);
	
	//Using and: (forall ((z3 Int) (_x1 Int)) (and (= _x1 0) (exists ((z4 Int)) (= z4 z3)))) -- unsat forall x1 . x1 = 0
}
//*/


/*
global protocol Proto1(role A, role B) @(x=1);
{
	1(y:int) from A to B; @((y=x) && (x=1));
	do Proto1(A, B); @(x+1);
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B; @(x=3);
	2(y:int) from A to B; @(y>x);
	
	do Proto1(A, B);
}
//*/


/*
global protocol Proto1(role A, role B) @(x=3);
{
	1(y:int) from A to B; @(y = x);
	2(z:int) from A to B; @(z = x);
}
//*/


/*
global protocol Proto1(role A, role B) @(x=3);
{
	choice at A
	{
		1(int) from A to B;
		do Proto1(A, B); @4;
	}
	or
	{
		2(int) from A to B;
		do Proto1(A, B); @3;
	}	

		//1(y:int) from A to B; @(x=4);

		//1(y:int) from A to B; @((y=4) && (x=y));
		
		//1(y:int) from A to B; @(x=y);


		//do Proto1(A, B); @3;
}
//*/


/*
//explicit 
global protocol Proto1(role A, role B) @(x=3);
{
	//1() connect A to B;
	2(y:int) from A to B; @(y=4);
	//3(z:int) from B to A; @((z=y) && (z=x));
	3(z:int) from B to A; @((z=y) && (z>x));
	
	do Proto1(A, B); @4;
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	1(x: int) from A to B; @(x > 6);

	//2(y: int) from B to A; @((y > x) && (y > 5));  // X
	//2(y: int) from B to A; @(y < x);  // X
	//2(y: int) from B to A; @(y = x);

	2(y: int) from B to A; @(y < 5);

	//3(z: int) from A to C; @(z < y);  // X
	//3(z: int) from A to C; @(z = y);  // X

	3(z: int) from A to C; @(z < 4);
}
//*/


/*
global protocol Proto1(role A, role B)
{
	rec X
	{
		choice at A
		{
			1(x:int) from A to B; @(x < 10);
			continue X;
		}
		or
		{
			2(y:int) from A to B; @(y > 5);
			continue X;
		}
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;	@(True && ((x+1) > 1));
	2(y:int) from A to B; @((y > 1) && (y = x));  // Not sat: x=1
}
//*/

/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{	
		1(int) from A to B;
		4(int) from A to C;
	}
	or
	{
		2(int) from A to B;
		3(int) from A to C;
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	choice at A
	{	
		1(x:int) from A to B;
		choice at A
		{
			2(y:int) from A to B;
			do Proto1(A, B);
		}
		or
		{
			3(z:int) from A to B;
		}
	
	}
	or
	{
		2(int) from A to B;
	}
}
//*/







/*
global protocol Proto1(role A, role B)
{
	choice at A
	{
		1(x:int) from A to B;
	}
	or
	{
		2(y:int) from A to B;
	}
	2(z:int) from A to B; 
	//2(y:int) from A to B;  // Uncomment is bad
}
//*/


/*
global protocol Proto1(role A, role B, role C, role D)
{
	1(x:int) from A to B;
	2(x:int) from C to D;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;
	2(x:int) from B to A;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;
	2(x:int) from A to B;
}
//*/


//---


/*
global protocol Proto1(role A, role B)
{
	(y:int) from A to C;
	(x:int) from A to B;
	[x=y]
	(x) from A to B;
	[x=y]
	(x) from A to B;

	(x:int) from A to B;
	(x) from A to B;

	(x:int) from A to B;
	(x) from B to A;
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	/*rec X
	{* /
		choice at A
		{
			1(y:int) from A to B;
			1(x:int) from B to C;
			//continue X;
		}
		or
		{
			2(y:int) from A to B;
			2(int) from B to C;
			2(x:int) from B to A;
		}
	//}
	[z=x]
	3(z:int) from B to A;  // In one case A knows x already, the other not
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1(y:int) from A to B;
		1(x:int) from B to C;
		//continue X;
	}
	or
	{
		2(x:int) from A to B;
		2(int) from B to C;
	}
	3(x) from B to C;  // CHECKME: One case B knows as receiver, the other as sender
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	rec X
	{
		choice at A
		{
			1(y:int) from A to B;
			1(x:int) from B to C;
			continue X;
		}
		or
		{
			2(y:int) from A to B;
			2(x:int) from B to C;
		}
	}
	3(x) from B to C;
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	rec X
	{
		choice at A
		{
			1(y:int) from A to B;
			1(x:int) from B to C;
			//continue X;
		}
		or
		{
			2(y:int) from A to B;
			2(x:int) from B to C;
		}
	}
	3(x) from B to C;
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
		choice at A
		{
			1(y:int) from A to B;
			1(x:int) from B to C;
		}
		or
		{
			2(y:int) from A to B;
			2(x:int) from B to C;
		}
	3(x) from B to C;
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1(y:int) from A to B;
		1(x:int) from B to C;
		//continue X;
	}
	or
	{
		2(y:int) from A to B;
		2(z:int) from B to C;
	}
	3(y) from A to B;
	//3(x) from A to B;  // Uncomment is bad
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1(y:int) from A to B;
		1(x:int) from B to C;
	}
	3(y) from A to B;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	rec X
	{
		1(x:int) from A to B;
	}
	2(x) from B to A;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	choice at A
	{
		1(x:int) from A to B;
	}
	or
	{
		2(y:int) from A to B;
	}
	3(y) from B to A;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;
	2(x) from B to A;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;
	2(x) from A to B;

}

//*/