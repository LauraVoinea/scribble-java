//Raymond@HZHL3 ~/code/eclipse/scribble/github.com/rumineykova/scribble-java
//$ bin/scribblec-assrt.sh -ip scribble-assertions/src/test/scrib/ -d scribble-assertions/src/test/scrib/ scribble-assertions/src/test/scrib/assrt/tmp/AssrtCoreTest.scr -V -ass Proto1


// http://sandbox.kidstrythisathome.com/erdos/




// FIXME: debug printing for assertion passes

// FIXME: distinguish branches where "not guaranteed safe" vs "impossible"



// unary choice: 
//   pre: forall (lhs)
//   forall lhs => (exists rhs) -- point is rhs may use vars in lhs
//   exists (lhs /\ rhs)
// -- forall [ (lhs /\ (lhs => (exists rhs))) => exists (lhs /\ rhs) ] -- ?
// -- forall [ lhs /\ (lhs => (exists rhs))) ] => forall [ exists (lhs /\ rhs) ] -- ?
/*
(declare-fun lhs (Int Int) Bool)
(declare-fun rhs (Int Int Int Int) Bool)
(assert (forall ((x1 Int) (y1 Int)) (lhs x1 y1)))
(assert  (=>   
  (forall ((x1 Int) (y1 Int)) (and (lhs x1 y1) (=> (lhs x1 y1) (exists ((x2 Int) (y2 Int)) (rhs x1 y1 x2 y2)))))
  (forall ((x1 Int) (y1 Int)) (exists ((x2 Int) (y2 Int)) (and (lhs x1 y1) (rhs x1 y1 x2 y2))))
))
(check-sat)
(exit)
*/


// FIXME: statevar decl invariants
// muZ for fixed points -- recursive statevar updates? -- http://rise4fun.com/Z3/tutorial/fixedpoints

// - assertion validation
// - receive assertions -- why receive assertions?  should WF imply receive assertions always true?
// - explicit connections

// .. checking assertions sender side only is important for services -- maybe complex/expensive operation, point is to ask service to do it, so must be the service only to check it also

//	.. rename connect to request
//	.. refactor a GConnectionAction (cf. LConnectionAction)

// .. need to update SubprotocolSig and "cycle" detection for protocoldecl/do annots? -- protocol inlining/unfolding with annots/assertions
// .. how about "syntactic" reachability check with protocoldecl/do annots?

// - recursion annotations
// - port forwarding annotations/assertions
// - arrays? -- cf. dependent types for array/list lengths -- https://www.reddit.com/r/fsharp/comments/28bbsr/faking_dependent_types_in_f/

// redo inlining/unfolding via model building? role/param/assert all in model states?



// unsat is a preserving safety error, op sem should freeze on an unsat choice -- but otherwise should allow branch selection, even if not "strictly" assert-prog
// assert-prog is a progress guarantee, but not a preserving safety error -- because assert-prog says there isn't a guaranteed option to proceed, but by op sem we can take any non-unsat case anyway

// try: simply compact all clauses with old vars -- since old var value is "lost", can never eval the clause anyway? -- model corresponds to the way syntactic var substitution works?
//		more explicitly, it corresponds to a scoping mechanism derived from syntactic source protocol that determines what vars can be "used" as constraints at protocol points?
// or continue-specific ("statevar update" of action) GC of clauses with old vars?

// F is a set of constraints that are true so far, but need to record to check more upcoming constraints
// once any clause has an "old var", can delete the clause because model is that we don't have old var value anymore so can't evaluate the constraint
// arguing about the "value" doesn't really make sense here, because doing forall anyway
// it's more like, "old var" ever won't be "used" in an upcoming constraint -- at least not "directly", but also not "indirectly"? -- also not "indrectly" because of "temporal ordering" given by syntax: e.g., x->y->z->loop, if x becomes old, then any upcoming use of y must also occur after y becomes old




module assrt.tmp.AssrtCoreTest;


type <dotnet> "System.UInt32" from "..." as int;
type <dotnet> "System.String" from "..." as str;




// TOO try: mu X . ( A->B 1 . X + A->B 2 . mu Y . A->B 3 . Y ) with statevars and assertions

/*
global protocol Proto1(role A, role B)
		@"(x := 1) (x>0)"
		//@"(x := 0) (x>0)"
{
	//1(y:int) from A to B; @"(y>1)"
	1() from A to B;
}
//*/

/*
global protocol Proto1(role A, role B)
{
	//1(y:int) from A to B; @"(y>1)"
	1(y:int) from A to B; @"(y>3)"
	do Proto2(A, B); @"(y)"
}

aux global protocol Proto2(role A, role B) @"(x := 0) (x>2)"
{
	2() from B to A;
}
//*/

/*
global protocol Proto1(role A, role B)  @"(x := 1)"
{
	1(y:int) from A to B;  @"(y > x)"
	2() from B to A;
	do Proto1(A, B);  @"(x)"
}
//*/

//*
global protocol Proto1(role A, role B)  
		@"(x := 3) (x>2)"
		//@"(x := 3) (x>0)"
		//@"(x := 3) (x>1)"
{
	1() from A to B; @"(x>1)"
	//2() from B to A;
	//do Proto1(A, B);  @"((x+1))"
	do Proto1(A, B);  @"((x-1))"
}
//*/

/*
//global protocol Proto1(role A, role B)  @"(x := 1)"
global protocol Proto1(role A, role B)  @"(x := 2) (x>1)"
//global protocol Proto1(role A, role B)  @"(x := 1) (y>0)"
{
	//1() from A to B;
	//1() from A to B; @"(x>0)"
	1() from A to B; @"(x>1)"
	2() from B to A;

	//do Proto1(A, B);  @"(x)"
	//do Proto1(A, B);  @"((x+1))"
	do Proto1(A, B);  @"((x-1))"
}
//*/

















// uninterpreted functions for custom API gen
// multi statvars -- fibo, linear
/*
global protocol Proto1(role A, role B) @"(x:=(0+3), y:=1)"
{
	1(z:int) from A to B;  @"(x>1)"
	do Proto1(A, B); @"(3, 1)"
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	1(lin x:int) from A to B; @port(x, C);  // implies port(x, C) and not(port(x, A)), not(port(x, B))
	
	rec X1 (used_x = 0) {

		1(z:int) from B to C; @(fw(x -> z) ... used_x =0); // implies port(x, C) and not(port(x, A)), not(port(x, B))
		
		rec X2 (used_x = 1) {

			1(z2:int) from B to C; @(... used_x = 0); // implies port(x, C) and not(port(x, A)), not(port(x, B))

			connect B to C;
			2(y:int) from B to A; @(x=y);

			connect C to A; @request(x, C);  // C should know x; should imply port(x, C);
		}
		}
} // terminal state needs all linear used
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B; 
	2(y:int) from B to A; @(x=y);
	3(z:int) from B to A; @(z=y);  // Should this be "linearity" error?
}
//*/


























/*/
global protocol Proto1(role A, role B) @(x=0);
{
	1() from A to B;
	do Proto2(A, B);
}

aux global protocol Proto2(role A, role B)
{
	2() from B to A; @(x<1);  // FIXME: shouldn't be in scope without decl as Proto2 statevar -- OK because aux? error caught if Proto2 checked as root
}
//*/

/*
global protocol Proto1(role B, role S)
{
	ok() from B to S;
	do Proto2(B, S); @Quote;  // FIXME: unknown vars check
}

global protocol Proto2(role B, role S) @(x=0);
{
	5() from B to S;	@False;//@(y>0);  // FIXME: unknown vars check here too?
}
//*/


/*
global protocol Proto1(role A, role B) @(z=3);
{
	1(x:int) from A to B; @(x=3);
	2(y:int) from A to B; @(y>x);
	do Proto1(A, B);  // FIXME: statevar arg check
}
//*/












/*
global protocol Proto1(role A, role B) @(x=3);
{
	1() from A to B; @(x>2);	
	do Proto2(A, B); @(x);  
			// FIXME: need to make expr vars old in F? -- proto shouldn't be valid?
			// could rename target y to x in this case? relies on "globally" (across subprotos) unique vars -- cf. rolename substitution
}

// Not aux
global protocol Proto2(role A, role B) @(y=4);
{
	1() from A to B; @(y>2);	
	do Proto1(A, B); @(y);
}
//*/

/*
global protocol Proto1(role A, role B)
{
	do Proto2(A, B); @1;  
			// FIXME: in this case, consider subsituting the x in Proto1<x+1> like DbC? but would be inconsistent generally?
			// FIXME: at least consider case for substituting x if syntactically just "x" and still just x -- cf. bad.extensions.assrtcore.safety.assrtprog.statevar.AssrtCoreTest08b
}

global protocol Proto2(role A, role B) @(x=1);
{
	1(y:int) from A to B; @((y=x) && (x=1));

	//do Proto1(A, B); @1;
	do Proto2(A, B); @(x+1);  
			// Unsat -- cf. DbC? -- OK there? but relies on two-unfolding cut off? 
			// No: DbC subs the x in X<x+1> fixing it to two at two unfoldings and forever after? that's why safe there
			
	// FIXME: check tests for "loop counting", e.g., X<x+1> -- and also with lower bounded ints (do bounds manually)
}
//*/

/*
global protocol Proto1(role A, role B) @(x=3);
{
	1() from A to B; @(x>2);	

	//do Proto1(A, B); @x;  // Currently unsat -- cf. DbC? -- DbC it wouldn't be "x", it would "already" be 3 from substitution
			// Note, Proto1 could be called from "any context", so x can really be anything
			// FIXME: make sat? treat single var formula as special case? cf. equality in "non-local" assertions vs. gt/lt

	//do Proto1(A, B); @(x+1);  // Unsat
	do Proto1(A, B); @(x-1);  // Unsat -- should be unsat
}
//*/

/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;
	do Proto2(A, B);
}

aux global protocol Proto2(role A, role B)
{
	2(x:int) from B to A;  // FIXME: need proper var shadowing
}
//*/
















// ---


/*
global protocol Proto1(role A, role B, role C)
{
	1(x:int) from A to B; @(x>3);
	2(y:int) from B to C; @(y>x);  // OK: B knows x

	//---

	1(x:int) from A to B; @(x>3);
	2() from B to C;
	3(y:int) from C to B; @(y>x);  // Bad: C doesn't know x -- though it knows x > 3 -- FIXME: how to disallow this? but still allow the below
			// CHECKME: DbC -- cf. HS
	
	//---	
	
	1(x:int) from A to B; @(x=3);  // FIXME: but equality should be strong enough?
	2() from B to C;
	3(y:int) from C to B; @(y>x);
}
//*/


/*
global protocol Proto1(role A, role B) @(z=0);
{
	1(x:int) from A to B; @(x>3);
	2(y:int) from B to C; @(y>x);  // C does *not* "know" x -- but knows constraints must be satisfied up to here
	3(z:int) from C to D; @(z>y);
	
//--- vs.

	1(x:int) from A to B; @(x=3);  // equality is "precise" enough for "strong path inference"
	2(y:int) from B to C; @(y>x);
	3(z:int) from C to D; @(z>y);
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	1(x:int) from A to B; @(x>1);
	2(y:int) from B to C; @(y>x);

	//3(z:int) from C to A; @(z=y);  // OK
	3(z:int) from C to A; @((z=y)&&(y>x));  //  Morally same as above -- given C should know this from the "path" here
			// FIXME? C doesn't know x -- but could pass prev assertions along with current? cf. DbC projection (at receiver)
			// DbC projection vs. HS/TS? -- DbC receive-exists projection vs HS/TS "forall"?
}
//*/



















/*
global protocol Proto1(role A, role B, role C)
{
	// testing "passing" rename (shadow) map with messages -- also need to test re-receiving rename map with already applied renaming

	1(x:int) from A to B; @(x>3);
	2(y:int) from B to C; @(y>x);  // compacting doesn't terminate -- FIXME: F renaming needs to be done based on K? i.e., also rename x in F(C)?
	//3(z:int) from C to D; @(z>x);  // ... FIXME: but what if C uses x again in upcoming assertions after the renaming? -- hence pass the renaming as a message
			// -- keep a ("one-level"?) rename map? -- cf. rec unfolding with rec-annotation substitution
			// -- no: C can't use x as a sender, not known; but how about as receiver?
			// -- should renamed vars be recorded in K?
	//3(z:int) from B to C; @(z>x);
	do Proto1(A, B, C);
}
//*/




























































// --- ???


/*
global protocol JavaSmtBug(role B, role S) @(x=0);
{
	5() from B to S;	@False;//@(y>0);
	do JavaSmtBug(B, S); @x;  // Cf. AssrtExistsFormula::toJavaSmtFormula comments
}
//*/


/*
global protocol Proto1(role A, role B) @(x=3);
{
	choice at A
	{
		1(int) from A to B;
		do Proto1(A, B); @4;
	}
	or
	{
		2(int) from A to B;
		do Proto1(A, B); @3;
	}	

		//1(y:int) from A to B; @(x=4);

		//1(y:int) from A to B; @((y=4) && (x=y));
		
		//1(y:int) from A to B; @(x=y);


		//do Proto1(A, B); @3;
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{	
		1(int) from A to B;
		4(int) from A to C;
	}
	or
	{
		2(int) from A to B;
		3(int) from A to C;
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	choice at A
	{	
		1(x:int) from A to B;
		choice at A
		{
			2(y:int) from A to B;
			do Proto1(A, B);
		}
		or
		{
			3(z:int) from A to B;
		}
	
	}
	or
	{
		2(int) from A to B;
	}
}
//*/

