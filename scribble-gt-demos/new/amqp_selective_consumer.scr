module amqp_selective_consumer;
data <java> "java.lang.Integer" from "rt.jar" as consumer_tag;
data <java> "java.lang.Integer" from "rt.jar" as delivery_tag;
data <java> "java.lang.String" from "rt.jar" as nowait;
data <java> "java.lang.String" from "rt.jar" as exchange;
data <java> "java.lang.String" from "rt.jar" as routing_key;
data <java> "java.lang.String" from "rt.jar" as pid;


global protocol AMQP(role Consumer, role Channel, role Server) {
    // consumers are monitored by channels once registered,

        // Consumer registers default consumer with Channel
        register_default_consumer() from Consumer to Channel;

        // Consumer sends a basic.consume message to the Channel
        basic_consume(consumer_tag, nowait) from Consumer to Channel;

        // Channel forwards the basic.consume message to the Server
        basic_consume(consumer_tag, nowait) from Channel to Server;

        // Server acknowledges the consume request by sending basic.consume_ok to the Channel
        basic_consume_ok(consumer_tag) from Server to Channel;

   // mixed{
        // Channel forwards the basic.consume_ok message to the Consumer
        basic_consume_ok(consumer_tag) from Channel to Consumer;

        rec SelectiveMessageDelivery{
            // Mixed block to represent selective message delivery
            mixed {
                // Choice at Server to deliver messages based on consumer tag
                choice at Server {
                    // If consumer is registered, deliver message to the Consumer
                    basic_deliver(consumer_tag, delivery_tag, exchange, routing_key) from Server to Channel;

                    // Abstracted message for syntactic purposes: projection onto Consumer
                    process_message() from Channel to Consumer;

                    // Mixed block to represent selective message delivery
                    mixed {
                        // Deliver to registered Consumer
                        basic_deliver(consumer_tag, delivery_tag, exchange, routing_key) from Channel to Consumer;

                        // Abstracted message for syntactic purposes: left-committing
                        processing_complete(delivery_tag) from Consumer to Channel;

                        // Abstracted message for syntactic purposes: left-committing
                        // Shouldn't introduce conflicting behaviour
                        update_delivery_state(delivery_tag) from Channel to Server;

                        continue SelectiveMessageDelivery;

                    }() or Channel -> Consumer() {
                        // In reality, the Consumer can cancel at any time
                        // Consumer initiates cancel
                        basic_cancel(consumer_tag, nowait) from Consumer to Channel;

                        // Channel forwards the cancel request to the Server
                        basic_cancel(consumer_tag, nowait) from Channel to Server;

                        // Server confirms the cancel request
                        basic_cancel_ok(consumer_tag) from Server to Channel;

                        // Channel forwards the cancel confirmation to the Consumer
                        basic_cancel_ok(consumer_tag) from Channel to Consumer;
                    }
                } or {
                    // In reality, the Server can cancel at any time
                    // Server initiates cancel
                    basic_cancel(consumer_tag, nowait) from Server to Channel;

                    // Channel acknowledges the cancel to Server
                    basic_cancel_ok(consumer_tag) from Channel to Server;

                    // Channel forwards the cancel request to the Consumer
                    basic_cancel(consumer_tag, nowait) from Channel to Consumer;

                    // Consumer acknowledges the cancel request
                   // basic_cancel_ok(consumer_tag) from Consumer to Channel; //dummy message
                }
            } () or Server -> Channel() {
                // Consumer initiates cancel
                // surprising that this is allowed here, i.e., in the Server -> Channel the first message is from Consume to Channel
                basic_cancel(consumer_tag, nowait) from Consumer to Channel;

                // Channel forwards the cancel request to the Server
                basic_cancel(consumer_tag, nowait) from Channel to Server;

                // Server confirms the cancel request
                basic_cancel_ok(consumer_tag) from Server to Channel;

                // Channel forwards the cancel confirmation to the Consumer
                basic_cancel_ok(consumer_tag) from Channel to Consumer;
            }
        }
   /* } () or Consumer -> Channel() {
        // Monitoring and lifecycle management of Consumers
        consumer_down(Pid) from Consumer to Channel;
    } */
    }

