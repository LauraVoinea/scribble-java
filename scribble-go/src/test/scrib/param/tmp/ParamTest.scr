//Raymond@HZHL3 ~/code/eclipse/scribble/github.com/rhu1-go/scribble-java
//$ bin/scribblec-param.sh -ip scribble-go/src/test/scrib/ -d scribble-go/src/test/scrib/ scribble-go/src/test/scrib/param/tmp/ParamTest.scr -V -param Proto1
//$ bin/scribblec-param.sh -ip scribble-go/src/test/scrib/ scribble-go/src/test/scrib/param/tmp/ParamTest.scr -V -param Proto1 github.com/rhu1-go/scribble-java/src/test/scrib/param/tmp/ParamTest -param-api S

// http://sandbox.kidstrythisathome.com/erdos/


module param.tmp.ParamTest;


//*
type <go> "int" from "builtin" as int;
type <go> "string" from "builtin" as string;
sig <go> "msgsig.Request" from "github.com/nickng/httpget/msgsig" as Request;
sig <go> "msgsig.Response" from "github.com/nickng/httpget/msgsig" as Response;

global protocol Proto1(role M, role F, role S) {
  URL(int) from M[1,1] to F[1,N];

  foreach F[I:1,N] {
    Request from F[I,I] to S[1,1];
    Response from S[1,1] to F[I,I];
    //tmp() from S[1,1] to M[1,1];  // FIXME: projection
  }

  Done(string) from F[1,N] to M[1,1];
}
//*/




/*
- keep P + coP for "actual roles" -- needed for API gen -- ParamRole => ParamRoleName?  cf. ParamRole ("actual")
- keep constraint for each "actual role" -- needed for API "selection" check
- index exprs
- WF G -- proto sig param decls
- examples


- how does prev pabble treat "actual roles"? e.g., pipeline
- how does prev pabble do projection wrt. arbitrary role ranges?


vs. pabble
- projection (distribution)
- type generation vs. code generation (related to above, heavyweight code generation needed because not fully projected)

message passing
- abstract transport -- shared mem, TCP -- integrated
- domain flexibility -- parallel algs, Web services -- shared parameterised abstraction, concrete transport independence


// encode "multi-choices" by local role(thread) forking/joining? for dynamic join/leave use param-value dependency? (run-time checked?)

// statechan interfaces -- use Go's structural typing, individual action funs -- combine with select-branch style
*/


// Add a scribble version and time/date to API output header


// paramterisation subsumes multicast


/*
type <go> "int" from "..." as int;
type <go> "string" from "..." as string;
type <go> "TwoBuyer.Address" from "scrib/twobuyer/TwoBuyer/TwoBuyer/types.go" as Address;
type <go> "TwoBuyer.Date" from "scrib/twobuyer/TwoBuyer/TwoBuyer/types.go" as Date;

sig <go> "..."
		from "..."
		as Data;

global protocol Proto1(role A, role B) {
  foreach A[I:1,K], B[J:2,KK]
  {
    Data from A[I,I] to B[J,J];
  }
}
//*/



/*global protocol ScatterGather(role M, role S) {
   (int) from M[1,1] to S[1,N];
}*/


/*
global protocol Proto1(role A(n))
{
	/*a() from A[n-1..n-1] to A[n..n];
	b() from A[n-2..n-2] to A[n..n];
	do Proto1(A(n-1));  // FIXME? * /

	a() dot A[1..1] to A[n..n];
}
//*/



/*
global protocol Proto1(role A(n, m), role B(n, m))
{
	1() from A[1..n] to B[1..m];  // (a) All-to-all, (unary) mult. choices
}

global protocol Proto2(role A(n), role B(n))
{
	1() dot A[1..n] to B[1..n];  // (b) ones-to-ones, (unary) multi. choices
}
//*/















/*global protocol Proto3(role A(n), role B(n))
{
	choices at A[i:1..n]
	{
		1() dot A[1..n] to B[1..n];  // TODO (b) ones-to-ones, multi. choices
	}
	or
	{
		2() dot A[1..n] to B[1..n];
	}
}*/


/*
global protocol Proto1(role A(n), role B(n))
{
	choice at A[1]
	{
		//0() from A[1..n] to B[1..n];  // FIXME when unary-choice -- or OK?
		//0() dot A[1..n] to B[1..n];  // FIXME when unary-choice -- or OK?
		0() from A[1..n] to B[1..n];
	}
	or
	{
		1() from A[1..n] to B[1..n];
	}
}
//*/


/*
global protocol Proto1(role A(n,m), role B(n,m))
{
	0() dot A[1..n] to B[(m*2)+1..(m*2)+n];
}
*/


/*
global protocol Proto1(role A(n), role B(n), role S(n))
{
	title(string) from A[1..1] to S[1..1];
	quote(int) from S[1..1] to A[1..1];
	quote(int) from S[1..1] to B[1..n];
	share(int) from A[1..1] to B[1..n];
	choice at B[1]
	{
		ok(Address) from B[1..1] to S[1..1];
		(Date) from S[1..1] to B[1..1];
		choice at B[1]
		{
			ok() from B[1..1] to B[2..n];
		}
		or
		{
			quit() from B[1..1] to B[2..n];
		}
	}
	or
	{
		quit() from B[1..1] to S[1..1];
		choice at B[1]
		{
			ok() from B[1..1] to B[2..n];
		}
		or
		{
			quit() from B[1..1] to B[2..n];
		}
	}
}
*/

/*
global protocol Proto1(role A(n, m), role B(n, m))
{
	1() from A[1..1] to B[n..n];  // Testing actual role "naming"
	2() from A[1..1] to B[m..m];
}
//*/


/*
global protocol Proto1(role A(n), role B(n))  // Testing API gen
{
	1() from A[1..1] to B[1..n];
	2() from B[1..n] to B[1..1];
}
//*/

/*
global protocol P1(role A(N), role B(N))
{
  Msg(int) from A[1..(N-1)] to B[1..1];
}

global protocol P2(role A(N), role B(N))
{
  Msg(int) from A[N..(N+N)] to B[1..1];
}
//*/


/*global protocol Proto1(role A(k), role B(k))
{
	1() from A[1..1] to B[k+k..(k+k)+k];
}*/

/*global protocol Proto1(role A(n, m), role B(n, m))
{
	//1() from A[1..m] to B[m+1..n];
	1() from A[1..m] to B[m+1..(m+1)+n];
}
//*/

/*
global protocol Proto1(role A(n), role B(n))
{
	choices at A[i:1..n]
	{
		1() from A[i] to B[1..1];
		3() from B[1..1] to A[1..n];
	}
	or
	{
		2() from A[i] to B[1..1];
		3() from B[1..1] to A[1..n];
	}
}
//*/


/*
global protocol Proto1(role A(n), role B(n))
{
	choices at A[i:1..n]
	{
		1() from A[i] to B[1..i];  // FIXME: bad "i"
		//1() from A[j] to B[1..1];  // FIXME: bad "i"
	}
}
//*/


/*
global protocol Proto1(role A(n), role B(n))
{
	1() dot A[1..n] to B[1+1..n+1];
}
//*/


/*
global protocol Proto1(role A(n))
{
	1() dot A[1..n] to A[2..n+1];
	2() dot A[3..n+3] to A[4..n+4];
}
//*/


/*
global protocol Proto1(role A(n))
{
	choice at A[1]
	{
		1() dot A[1..n] to A[2..n+1];
	}
	or
	{
		2() dot A[1..n] to A[2..n+1];
		//2() dot A[2..n+1] to A[1..n];  // Bad: non-directed
	}


	/*choices at A[i:1..n]
	{
		1() from A[i] to B[1..1];
		//1() from B[1..1] to A[i];  // Not allowed
	}* /
}
//*/


/*
global protocol Proto1(role A(n), role B(n))
{
	choices at A[i:1..n]
	{
		//1(int) from A[i+1] to B[1..1];  // Allow?

		//1(int) from A[i] to B[i+1];   // Allow?  // Key point of foreach? relative indexing -- how to derive actual roles?
				// A[i:1..n] ->* B[i+1:1..n]: 1() . end  ?
				// for (i:1..n) ( A[i] ->* B[i+1]: 1() . end )
	}
}
//*/


/*
global protocol Proto1(role A(n), role B(n))
{
	/*choices at A[i:1..n]
	{
		1() from A[i] to B[1..1];
	}* /

	/*choice at A[1]
	{
		1() from A[1..1] to B[1..1];
	}* /
	
	1() from A[1..n] to B[1..1];  // Above and this are equivalent for n=1
}
//*/


/*
global protocol Proto1(role A(n), role B(n))
{
	choices at A[i:1..n]
	{
		1() from A[i] to B[1..2];

		//3() from A[1..n] to B[1..2];
	}
	or
	{
		2() from A[i] to B[1..2];
		//2() from A[1..1] to B[1..2];

		//3() from A[1..n] to B[1..2];  // OK
		//3() from A[1..1] to B[1..2];  // Bad
	}	

	//3() from A[1..n] to B[1..2];  // FIXME: support this for param-core multi-choices?
}
//*/





/*
global protocol Proto1(role A(n), role B(n))
{
	//choice at A[i:1..n]
	choice at A[1]
	{
		1() from A[1..1] to B[1..2];  // OK

		//1() from A[1..2] to B[1..2];  // Bad
		//1() from A[1..n] to B[1..2];  // Bad
	}
	or
	{
		2() from A[1..1] to B[1..2];
	}	
}
//*/




/*// A=Auctioneer, B=Bidder
global protocol Auction(role A(n), role B(n))
{
	bid(int) from B[1..n] to A;   // A[1..1]

	do X(A, B);
}

// mu X
aux global protocol X(role A, role B(n))
{
	choice at A
	{	
		highestbid(int) from A to B[1..n];	

		specialchoice at B[i:1..n] 
		{
			bid(int) specialarrow B[i] to A;
		}
		or
		{
			skip(int) specialarrow B[i] to A;
		}


		for (i: 1..n)
		{
			choice at B[i]
			{
				bid(int) from B[i] to A;
			}
			or
			{
				skip(int) from B[i] to A;
			}
		}
		//bidOrSkip(int) from B[1..n] to A;

		do X(A, B);
	}
	or
	{
		winner() from A to B[1..n];
	}
}
//*/


	/*choice at B[1..n]
	{
		bid() fromto A;
	}
	or
	{
		skip() from B[1..n] to A;
	}*/







/*
global protocol Proto1(role A(n), role B(n))
{
	/*bid() from B[1..n] to A[1..1];

	...

	bidorskip(x:int) from B[1..n] to A[1..1];
	
	choice at A[1]
	{
		highestbid() from A[1..1] to B[1..n];
		do Proto1(A, B);
	}
	or
	{

		win() from A[1..1] to B[1..n];
	}*/

	
	/*do MyBiddingSubproto(A, B);
	do MyBiddingSubproto(A, C);
	do MyBiddingSubproto(A, D);
	...

		
	for (i 1 .. N)
	{
		do MyBiddingSubproto(A, B[i]);
	}* /
	
	choice at B[1..n]
	{
		bid() from B[1..n] to A[1..1];
	}
	or
	{
		skip() from B[1..n] to A[1..1];
	}

	bidorskip(x:int) from B[1..n] to A[1..1];

	G
}



/*
global protocol Proto1(role A(n, m), role B(n, m))
{
	1() from A[1..1] to B[1..m*n];
}
//*/


/*
global protocol Proto1(role A(n, m))
//global protocol Proto1(role A(n, m), role B(n, m))
{
	//1() from A[1..n-1] to A[2..2];  // Currently bad range interval under n>=1

	//1() from A[1..n+1] to A[2..2];  // Bad, overlapping for n>=1

	//1() from A[1..n+m] to B[1..1];  // OK

	//1() from A[1..n+m] to A[1..1];  // Bad, overlapping
	
	1() from A[1..1] to A[n..n+1];  // Bad
	//1() from A[1..1] to A[n+1..n+2];  // OK
}
//*/


/*
//global protocol Proto1(role A(n, m))
global protocol Proto1(role A(n, m), role B(n, m))
{
	//1() dot A[1..n] to A[1..n];  // Bad -- ruled out by self-comm

	//1() dot A[1..n] to A[2..n+1];  // OK

	//1() dot A[1..n] to A[1+1..n+2];  // Bad
	
	//1() dot A[1..1+n] to A[m..m+n];  // Bad
	//1() dot A[1..1+n] to A[2..2+n];  // OK
	
	//1() dot A[1..1+n] to B[1..1+m];  // Bad
	//1() dot A[1..1+n] to B[m..m+n];  // OK
}
//*/

/*
global protocol Proto1(role A, role B)
{
	choice at A[1]
	{
		1() from A[1..1] to B[1..2];
	}
	or
	{
		2() from A[1..1] to B[1..2];
	}
}
//*/

/*
global protocol Proto1(role A, role B)
{
	choice at A[1]
	{
		1() from A[1..1] to B[1..1];
		1() from A[1..1] to B[2..2];  // Bad, non-directed choice
	}
	or
	{
		2() from A[1..1] to B[2..2];
		2() from A[1..1] to B[1..1];
	}
}
//*/

/*
global protocol Proto1(role A, role B)
{
	choice at A[1]
	{
		1() from A[2..2] to B[1..1];  // FIXME: role-enabling -- Scribble detail, also proto sig param decls
	}
}
//*/

/*
global protocol Proto1(role A)
{
	//1() from A[1..1] to A[2..2];  // OK
	//1() from A[1..1] to A[1..1];  // Bad
	1() from A[1..1] to A[1..2];  // FIXME: should be bad
}
//*/


/*
global protocol Proto1(role A(n), role B(n))
{
	1() from A[1..1] to B[1..n];
	2() from B[1..n] to A[1..1];
	//do Proto1(A, B);  // OK
	do Proto1(B, A);  // OK because same "param knowledge"? -- cf. computed roles
}
//*/

/*
global protocol Proto1(role A(n), role B(n, m), role C(m)
{
	1() from A[1..1] to B[1..n];
	2() from B[1..n] to A[1..1];

	3() from B[1..1] to C[1..m];
	4() from C[1..m] to B[1..1];

	do Proto1(C, B, A);  // Bad because different "param knowledge"?
	//do Proto1(B, A, C);  // Also bad
}
//*/














/*
global protocol Proto1(role A(n), role B(n))
{
	choice at A[1]
	{
		1(int) from A[1..1] to B[1..n];
	}	
	or
	{
		//2(int) from A[1..1] to B[1..n-1];
		2(int) from A[1..1] to B[1..n];
	}	
}
//*/

/*/
global protocol Proto1(role A(m,n), role B(m,n))
{
	1() from A[1..1] to B[1..n];
	2() from B[1..n-1] to A[1..1];
}
//*/

/*
global protocol Proto1(role A(n), role B(n))
{
	1() from A[2..n] to B[2..n];
	//1() dot A[1..n] to B[1..n];
}
//*/

























/*
global protocol Proto1(role A, role B(n))
{
	1() from A[1..1] to B[1..n];
	2() from B[1..n] to A[1..1];
}
//*/


/*
global protocol Proto1(role A, role B(n))  // n = 1 gives 2 roles; n > 1 gives 3 roles
{
	1() from A[1..1] to B[1..n];
	2() from B[1..1] to A[1..1];
}
//*/


/*
global protocol Proto1(role A, role B(n,m))
{
	1() from A[1..1] to B[1..n];
	2() from B[1..m] to A[1..1];
}
//*/


/*
global protocol Proto1(role A(n), role B(m))
{
	1() from A[1..n] to B[1..m];
	2() from B[1..m] to A[1..n];
}
//*/


/*
global protocol Proto1(role A, role B(n))
{
	1() from A[1..1] to B[1..n];
	2() from B[2..n] to A[1..1];
}
//*/


/*
global protocol Proto1(role A, role B(n,m))
{
	1() from A[1..1] to B[1..n];
	2() from B[2..m] to A[1..1];
}
//*/


/*
global protocol Proto1(role A, role B)
{
	choice at A
	{
		1() from A[1..1] to B[1..2];
		2() from B[1..1] to A[1..1];
	}
	or
	{
		3() from A[1..1] to B[1..2];
		4() from B[2..2] to A[1..1];
	}
}
//*/
